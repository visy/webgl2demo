<html>
<head>
 <link rel="stylesheet" type="text/css" href="stylesheet.css">
<style type = "text/css">
canvas {
    z-index: 6;    
}

body {
  margin: 0px;
  overflow: hidden;
  font-family: "XIPAROS";
  line-height: 0.0;
  font-size:6em; 
}

p{
  position:fixed;
  opacity: 0.0;
}

span{
  position:fixed;
  top:50%;

  padding: 10px;
  text-shadow: 2px 2px #000000; 
  color: white; 

}

</style>
<script src = "jquery-3.2.1.min.js"></script>
<script src = "three.min.js"></script>
<script src = "postprocessing.js"></script>
<script src = "ColladaLoader.js"></script>
<script src = "TargetCamera.js"></script>
<script src = "GLTFLoader.js"></script>
<script src = "TexGen.js"></script>
<script src = "ShaderExtras.js"></script>
<script src = "perlin.js"></script>
<script src = "jsRocket.js"></script>
<script src = "syncdata.js"></script>
<script src = "synctrack.js"></script>
<script src = "syncdeviceplayer.js"></script>
<script src = "syncdeviceclient.js"></script>
<script src = "syncdevice.js"></script>

<script id = "vertexShader" type = "glsl">

varying vec2 vUv; 

void main()
{
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id = "fragmentTolppa" type = "glsl">
uniform float iTime;
uniform float iAlpha;
varying vec2 vUv;

float NEAR_CLIPPING_PLANE=.005;
float FAR_CLIPPING_PLANE=20.;
int NUMBER_OF_MARCH_STEPS=500;
float EPSILON=.1;
float DISTANCE_BIAS=.3;
float t = 0.;

float sdSphere(vec3 p, float s)
{
    return length(p) - (s);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float fOpUnionRound(float a, float b, float r) {
    vec2 u = max(vec2(r - a,r - b), vec2(0));
    return max(r, min (a, b)) - length(u);
}


float scene(vec3 pos)
{
    vec3 translate1 = vec3(-0.1, fract(pos.y*clamp(iTime*0.05,0.,1.0)), 0.);
    vec3 translate2 = vec3(0.0,distance(1.+abs(cos(pos.x*0.1+cos(iTime*0.1+pos.z+pos.x)*0.5)*10.),pos.y-8.+cos(pos.z)),cos(pos.x+iTime));

    vec3 translate = translate2;

    vec3 opos = pos - translate;

    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.001+cos(pos.x*1.1)*0.1)*0.2)*3.91;

    return finalDist;
}

vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.;
    for(int i = 0 ; i < 500 ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        float result = scene(pos);
        acc+=result*0.2;

        if(result < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result * DISTANCE_BIAS;
                
        if(total_distance > FAR_CLIPPING_PLANE) return vec2(0.0,-1.0);
    }
    return vec2(0.0,-1.0);
}

vec3 nr(vec3 n) {
    return normalize(n);
}

vec3 normal( in vec3 pos )
{
    vec3 eps = vec3(.3,0.,0.)*EPSILON;
    vec3 nor = vec3(
        scene(pos+eps.xyy) - scene(pos-eps.xyy),
        scene(pos+eps.yxy) - scene(pos-eps.yxy),
        scene(pos+eps.yyx) - scene(pos-eps.yyx) );
    return nr(nor);
}



float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1., max(NdotL, NdotV), step(0., s));

  float sigma2 = roughness * roughness;
  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));
  float B = .45 * sigma2 / (sigma2 + .09);

  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;
}

void main() {
    // pixel coordinates
    vec2 uv = -1.0 + 2.0 * vUv;
    
    vec3 direction = nr(vec3(uv, 0.));

    t = iTime*0.5;

    float cz = t*5.9;
    

    float FOV = 10.0;
        
        vec3 camera_origin = vec3(0., 1., cz);
    vec3 lookAt = vec3(0.0,2.,cz+1.);
    
    vec3 forward = nr(lookAt-camera_origin);
    vec3 right = nr(vec3(forward.z, 0., -forward.x ));
    vec3 up = nr(cross(forward,right));

    
    vec3 ro = camera_origin;
    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    if (result.y == -1.0) gl_FragColor = vec4(0.0,0.0,0.0,0.0);
    else {
        float fog = pow(1. / (1. + result.x), .2);
        
        vec3 materialColor = vec3(1.3-result.x*.01*.5,.9,1.*.5)*0.2;
        vec3 intersection = ro + rd*result.x;
        
        vec3 nrml = normal(intersection);
        vec3 light_dir = nr(vec3(0.,.0,-1.));
        vec3 ref = reflect( rd, nrml );

        float dom = smoothstep( -.1, .9, ref.y);
        float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);

        float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.0,0.5)-result.y*.05;
        
        vec3 light_color = vec3(1.);
        vec3 ambient_color = light_color;
        vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
        vec3 outColor = diffuseLit*fog+dom*.2+spe*.5;
        gl_FragColor = vec4(outColor,iAlpha*(1.0-distance(0.5,result.x)*.1));
    }
 }
</script>

<script id = "fragmentPalaset" type = "glsl">
uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
varying vec2 vUv;
float PI=3.14159;

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898+co.y,78.233+co.x))) * 5.*iTime*0.01+43758.5453);
}

float pix(vec2 uv){
    return step(0.5+uv.y*0.01+(cos(uv.x*0.01+10.*iTime*0.5)*0.001),rand(floor(uv)));    
}

float hm(vec2 uv){
    uv*=2.0;
    vec2 nuv = (fract(uv)-0.5)*4.;
    vec2 pos = sign(nuv)*0.4-distance(nuv.yx,uv.yx)*(cos(10.*iTime+nuv.x*nuv.y)*0.04);
    
    float d = length(nuv);
    
    float v = pix(uv);
    
    if(d>1.){
    
    vec2 p1=vec2(pos.x,0.),
         p2=vec2(0.,pos.y);
    
    float v1 = pix(uv+p1),
          v2 = pix(uv+p2);
    
        if(v1==v2){
            if(v==pix(uv+pos) && v!=v1) v=0.;
            else v=v1;
        }
    }   
    
    return mix(pix(uv),v,smoothstep(d,1.0,1.1));
}

vec3 shade(vec2 uv){
    uv*=5.;
    return vec3(hm(uv));
}

void main()
{
    vec2 uv = -1.0 + 2.0 * vUv*3.;
    if (uv.x < 0.0) uv.x = 0.0-uv.x;
    if (uv.y < 0.0) uv.y = 0.0-uv.y;
    
    vec3 color = shade(uv);
    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) discard;
    color.rgb*=texture2D(iChannel1,uv).rgb;
    color.rgb-=texture2D(iChannel0,uv+iTime*0.2).rgb*0.5;
    gl_FragColor = vec4(color*vec3(1.1,1.3,0.4),0.5);
}

</script>

<script src = "orbit.js"></script>
<script src = "quad.js"></script>

<script>

// Rose by cosmicollie is licensed under CC Attribution-NonCommercial
// polliisi by Juha M (from Sketchfab)
// castle & time fuse by Skoklosters slott Time Fuse is licensed under CC Attribution-ShareAlike
// Abandoned Warehouse - Interior Scene(https://sketchfab.com/models/1d5285f2e0fd4211a27c8042496d5959) by AurÃ©lien Martel(https://sketchfab.com/aurelien_martel) is licensed under CC Attribution(http://creativecommons.org/licenses/by/4.0/)

var camera;
var cameraPalaset, cameraTolppa, cameraTori, cameraHall, scenePalaset, sceneTolppa, sceneTori, sceneHall, sceneTolppa2;
var renderer;
var geometry, material, sphereMesh;
var tuniform, clock, audioElement;
var millis, sceneIndex, prevSceneIndex;
var screenQuad, sphereMesh2, composerTolppa, composerPalaset, composerTori, composerHall, materialTolppa, scenePass;
var syncReady = false;
var roseclone, poliis, bokeh, bokehrose;

var spotLight_tori2, spotLight_tori1;

var spotLight_hall1;
var tgTexture;

var hallMeshes = new Array()

var demoMode = true;

var syncDevice,
    //Beats per minute of your demo tune
    BPM = 135,
    //The resolution between two beats, four is usually fine,- eight adds a bit more finer control
    ROWS_PER_BEAT = 8,
    //we calculate this now, so we can translate between rows and seconds later on
    ROW_RATE = BPM / 60 * ROWS_PER_BEAT,
    //your variable that needs tuning in Rocket
    rocket_meshx,
    rocket_meshy,
    rocket_meshz,
    rocket_meshr,
    rocket_mesha,
    rocket_camerax,
    rocket_cameray,
    rocket_cameraz,
    rocket_camerarx,
    rocket_camerary,
    rocket_camerarz,
    rocket_effutime,
    current_scene,
    rocket_aperture,
    rocket_dof,
    rocket_focus,
    rocket_textIndex,
    //the current row we're on
    row = 0;


var gltfcount = 0;
var allmodelscount = 4;
var audioInited = false;
// demo init

function addGLTFCount() {
    gltfcount++;
    console.log("gltfcount:" + gltfcount);

    var dd = document.getElementById("loader");
    loader.innerHTML = "loading (" +gltfcount+"/"+allmodelscount+")"; 
    if (gltfcount >= allmodelscount && !audioInited) {
    console.log("all models loaded");
        modelsdone();
    }
}

function modelsdone() {
    loader.innerHTML = "initializing demo...";
    audioElement.oncanplaythrough = onAudioReady;
    setTimeout(function() { audioElement.load(); }, 200);

}

function loadModels() {
    var loadergltf = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf.load(
        // resource URL
        'rose.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();

            gltf.scene.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {

                    roseclone = child.clone();
                    roseclone.position.z = 1.2;
                    roseclone.position.y = -0.6;
                    roseclone.rotation.x = -2.;
                    roseclone.scale.set(0.2,0.2,0.2);
                    scenePalaset.add(roseclone);

                    child.position.z = 4.9;
                    child.rotation.x = -0.9;
                    child.rotation.y = 1.5;
                    child.rotation.z = 2.5;
                    child.position.y = -2.2;
                    child.position.x = -0.5;
                    child.scale.set(0.2,0.2,0.2);
                    sceneTolppa.add( child );                    
                }
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );


    var loadergltf2 = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf2.load(
        // resource URL
        'torip.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();

            gltf.scene.traverse( function ( child ) {

                    child.position.x = 0.0;
                    child.position.y = -20.0;
                    child.position.z = -25.0;

                    child.rotation.x = -1.25;
                    child.rotation.y = 0.0;
                    child.rotation.z = 1.0;

                    child.scale.set(1.3,1.3,1.3);
                    sceneTori.add( child );            


                    poliis = child;     


                    cameraTori.addTarget({
                    name: 'poliistarget',
                    targetObject: poliis,
                    cameraPosition: new THREE.Vector3(0, 0, 10),
                    fixed: false,
                    stiffness: 0.1,
                    matchRotation: true
                });   
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );


    var loadergltf3 = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf3.load(
        // resource URL
        'abandoned_warehouse_-_interior_scene/scene.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();

            var ii = 0;
            gltf.scene.traverse( function ( child ) {
//                if ( child instanceof THREE.Mesh ) {
                    child.rotation.x += 0.0;
                    hallMeshes.push(child);
                    sceneHall.add( child );            

//                }
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );

    var loadergltf4 = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf4.load(
        // resource URL
        'time_fuse/scene.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();
            gltf.scene.traverse( function ( child ) {
//                if ( child instanceof THREE.Mesh ) {
                    child.position.x -= 2.;
                    child.position.y -= 0.;
                    child.position.z -= 24.;
                    child.rotation.x = 1.;
                    scenePalaset.add( child );            
//                    child.visible = false;
//                }
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );

}

function init() {

    cameraPalaset = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.01, 100 );
    cameraTolppa = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        cameraPalaset.position.z = 0.2;
    cameraTori = new THREE.TargetCamera( 80, window.innerWidth / window.innerHeight, 0.01, 1000 );
    cameraHall = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.01, 100 );

    window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize(){
        cameraPalaset.aspect = window.innerWidth / window.innerHeight;
        cameraPalaset.updateProjectionMatrix();
        cameraTolppa.aspect = window.innerWidth / window.innerHeight;
        cameraTolppa.updateProjectionMatrix();
        cameraTori.aspect = window.innerWidth / window.innerHeight;
        cameraTori.updateProjectionMatrix();

        cameraHall.aspect = window.innerWidth / window.innerHeight;
        cameraHall.updateProjectionMatrix();

        screenQuad.setScreenSize( window.innerWidth*0.1, window.innerHeight*0.1 );
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    prevSceneIndex = -1;
    sceneIndex = 1;

    clock = new THREE.Clock;
    scenePalaset = new THREE.Scene();
    sceneTolppa = new THREE.Scene();
    sceneTolppa2 = new THREE.Scene();
    sceneTori = new THREE.Scene();
    sceneHall = new THREE.Scene();

    var loader = new THREE.TextureLoader();
    
    tuniform = {
        iTime:      { type: 'f', value: 0.1 },
        iAlpha:     { type: 'f', value: 1.0 }, 
        iChannel0:  { type: 't', value: loader.load( 'tex1.jpg') },
        iChannel1:  { type: 't', value: loader.load( 'tex2.jpg' ) },
    };

    tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
    tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

    var materialPala = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentPalaset' ).textContent,
        side:THREE.DoubleSide,
        transparent: true,
    });


    materialTolppa = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentTolppa' ).textContent,
        transparent: true,
        side:THREE.DoubleSide,
    });


    loadModels();

    geometry = new THREE.SphereGeometry( 0.2, 16, 16 );
    sphereMesh = new THREE.Mesh( geometry, materialPala );
    sphereMesh.receiveShadow = false;
    sphereMesh.castShadow = false;
//  scenePalaset.add( sphereMesh );

    var path = "bud/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube = new THREE.CubeTextureLoader().load( urls );
    cube.format = THREE.RGBFormat;


    var path = "horn/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube2 = new THREE.CubeTextureLoader().load( urls );
    cube2.format = THREE.RGBFormat;

    var i = 0;
    tgTexture = new TG.Texture(1024, 1024)
    .add( new TG.SinX().frequency( 0.066 + 0.05*Math.sin(1) ) )
    .add( new TG.SinY().frequency( 0.066 + 0.05*Math.sin(1) ) )
    .mul( new TG.SinX().offset( 25. ).frequency( 0.044 + 0.09*Math.sin(i/100) ).tint( 2, 2, 2 ) )
    .mul( new TG.SinY().offset( 16 ).frequency( 0.044 + 0.09*Math.sin(i/100) ).tint( 2, 2, 2 ) )
    .sub( new TG.Number().tint( 0.5, 2, 4. ) );

    tgTexture = new THREE.Texture(tgTexture.toCanvas());
    tgTexture.needsUpdate = true;


    sceneTolppa.background = cube;
    scenePalaset.background = cube2;
    sceneTori.background = cube2;
    sceneHall.background = cube2;

    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, -5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    scenePalaset.add(spotLight);

    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 10, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 5.0;
    scenePalaset.add(spotLight);

    var spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(0, 1, 5);
    spotLight2.castShadow = false;
    spotLight2.intensity = 0.2;
    scenePalaset.add(spotLight2);

    spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(5, 10, -5);
    spotLight2.castShadow = false;
    spotLight2.intensity = 0.5;
    scenePalaset.add(spotLight2);

    var spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(1, 5, -100);
    spotLight2.castShadow = false;
    spotLight2.intensity = 2.0;
    sceneTolppa.add(spotLight2);

    spotLight_tori1 = new THREE.SpotLight(0xffaaaa);
    spotLight_tori1.position.set(1, -1, 10);
    spotLight_tori1.castShadow = false;
    spotLight_tori1.intensity = 1.0;
    sceneTori.add(spotLight_tori1);

    spotLight_tori2 = new THREE.SpotLight(0xaaffff);
    spotLight_tori2.position.set(0, 1, 10);
    spotLight_tori2.castShadow = false;
    spotLight_tori2.intensity = 1.0;
    sceneTori.add(spotLight_tori2);


    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 5, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 1.0;
    sceneHall.add(spotLight);

    spotLight_hall1 = spotLight;

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(5, 0, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, -5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, 5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);


    screenQuad = new ScreenQuad({
        width: 1.,
        height: 1.,
    });

    renderer = new THREE.WebGLRenderer( { antialias: false } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio*1.0 );
    renderer.setClearColor( 0x000000, 1);
    renderer.shadowMapEnabled = false;
    renderer.shadowMapType = THREE.PCFSoftShadowMap; 

    screenQuad.setScreenSize( renderer.getSize().width , renderer.getSize().height );
    screenQuad.material = materialTolppa;

    sphereMesh2 = new THREE.Mesh( geometry, materialTolppa );

    sceneTolppa.add(sphereMesh2);

    composerTolppa = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneTolppa, cameraTolppa)
    composerTolppa.addPass(scenePass);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerTolppa.addPass(smaapass);
    var pass = new POSTPROCESSING.GodRaysPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = false;
    composerTolppa.addPass(pass);
    var pass = new POSTPROCESSING.FilmPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = true;
    composerTolppa.addPass(pass);


    composerPalaset = new POSTPROCESSING.EffectComposer(renderer);
    var scenePass2 = new POSTPROCESSING.RenderPass(scenePalaset, cameraPalaset)
    composerPalaset.addPass(scenePass2);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerPalaset.addPass(smaapass);
    var bokehPass2 =  new POSTPROCESSING.BokehPass(cameraPalaset);
    bokehPass2.renderToScreen = false;
    composerPalaset.addPass(bokehPass2);
    bokehrose = bokehPass2;
    var pass = new POSTPROCESSING.FilmPass(scenePalaset,cameraPalaset);
    pass.renderToScreen = true;
    composerPalaset.addPass(pass);


    composerTori = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneTori, cameraTori)
    composerTori.addPass(scenePass);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerTori.addPass(smaapass);
    var pass = new POSTPROCESSING.FilmPass(sceneTori,cameraTori);
    pass.renderToScreen = true;
    composerTori.addPass(pass);


    renderTargetParameters = { format: THREE.RGBAFormat, stencilBuffer: false };

    renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters );            
    effectSaveTarget = new POSTPROCESSING.SavePass( new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters ) );
    effectSaveTarget.clear = false;

    effectBlend = new POSTPROCESSING.TexturePass( effectSaveTarget.renderTarget );   
    effectBlend.opacity = 0.5;

    composerHall = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneHall, cameraHall)
    composerHall.addPass(scenePass);
    effectSaveTarget.renderToScreen = false;
    composerHall.addPass( effectSaveTarget );
    effectBlend.renderToScreen = false;
    composerHall.addPass( effectBlend );
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerHall.addPass(smaapass);

    var bokehPass =  new POSTPROCESSING.BokehPass(cameraHall);
    bokehPass.renderToScreen = false;
    composerHall.addPass(bokehPass);
    bokeh = bokehPass;
    var pass = new POSTPROCESSING.FilmPass(sceneHall,cameraHall);
    pass.renderToScreen = true;
    composerHall.addPass(pass);

    document.body.appendChild( renderer.domElement );

    syncDevice = new JSRocket.SyncDevice();
    if (demoMode) {
        syncDevice.setConfig({'rocketXML':'sync2.rocket'});
        syncDevice.init("demo");
    } else {
        //_syncDevice.setConfig({'socketURL':'ws://192.168.0.100:1339'});
        syncDevice.init();
    }
    syncDevice.on('ready', onSyncReady);
    syncDevice.on('update', onSyncUpdate);
    syncDevice.on('play', onPlay);
    syncDevice.on('pause', onPause);

    audioElement = document.getElementById("audio");


}

var preloader = 0;

function preloadScenes() {
    if (preloader == 0) {
        scenePass.camera = cameraTolppa;
        scenePass.scene = sceneTolppa;
        composerTolppa.render(100*preloader);
    } else if (preloader == 1) {  
        scenePass.camera = cameraHall;
        scenePass.scene = sceneHall;
        composerHall.render(100*preloader); 
    } else if (preloader == 2) {  
        scenePass.camera = cameraPalaset;
        scenePass.scene = scenePalaset;
        composerPalaset.render(100*preloader);
    } else if (preloader == 3) {  
        scenePass.camera = cameraTori;
        scenePass.scene = sceneTori;
        composerTori.render(100*preloader);
    }

    preloader++;
    if (preloader < 4) setTimeout(preloadScenes, 100);
    else render();

}




function onAudioReady() {
    audioInited = true;
    setTimeout(preloadScenes, 500);
}

function onSyncReady(){
  //jsRocket is done getting all the info you already have in Rocket, or is done parsing the .rocket file

  //this either adds a track to Rocket, or gets it for you
  current_scene = syncDevice.getTrack('current_scene');
  rocket_meshx = syncDevice.getTrack('mesh_x');
  rocket_meshy = syncDevice.getTrack('mesh_y');
  rocket_meshz = syncDevice.getTrack('mesh_z');
  rocket_meshr = syncDevice.getTrack('mesh_r');
  rocket_mesha = syncDevice.getTrack('mesh_a');

  rocket_camerax = syncDevice.getTrack('camera_x');
  rocket_cameray = syncDevice.getTrack('camera_y');
  rocket_cameraz = syncDevice.getTrack('camera_z');
  rocket_camerarx = syncDevice.getTrack('camera_rx');
  rocket_camerary = syncDevice.getTrack('camera_ry');
  rocket_camerarz = syncDevice.getTrack('camera_rz');
  rocket_effutime = syncDevice.getTrack('effutime');

  rocket_aperture = syncDevice.getTrack('aperture');
  rocket_dof = syncDevice.getTrack('dof');
  rocket_focus = syncDevice.getTrack('focus');

  rocket_textIndex = syncDevice.getTrack('current_text');

  syncReady = true;
}

function onSyncUpdate(newRow){
  //row is only given if you navigate, or change a value on the row in Rocket
  //on interpolation change (hit [i]) no row value is sent, as the current there is the upper row of your block
  if(!isNaN(row)){
    row = newRow;
  }
  audioElement.currentTime = row/ROW_RATE;
  render();
}

function onPlay(){
  //you could also set tune.currentTime here
  console.log("[onPlay] time in seconds", row / ROW_RATE);
  audioElement.play();
  render();
}

function onPause(){
  //pause your tune
  console.log("[onPause] time in seconds", row / ROW_RATE);
  audioElement.pause();
}

var sceneTime = 0;
var sceneStartTime = 0;
var prevTime = 0;
var delta = 0;
var meshcopy = null;
var cposx = new Array(100);
var cposy = new Array(100);
var cposz = new Array(100);
var demoTime = 0;
var textIndex = -1;

function clamp(num, min, max) {
  return num <= min ? min : num >= max ? max : num;
}

function easeInOut(t) {
  return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1
}

function render() {
    if (syncReady === false) return;
    var currentRow = audioElement.currentTime * ROW_RATE;
            if(audioElement.paused === false) {
                //otherwise we may jump into a point in the audio where there's
                //no timeframe, resulting in Rocket setting row 2 and we report
                //row 1 back - thus Rocket spasming out
                // this informs Rocket where we are
                syncDevice.update(currentRow);
            }

    millis = (currentRow/ROW_RATE)-sceneStartTime;

    delta = millis-prevTime;
    sceneTime+=delta;

    sceneIndex = current_scene.getValue(currentRow);

    demoTime += delta;

    if (prevSceneIndex != sceneIndex) {
        prevSceneIndex = sceneIndex;
        sceneStartTime = (currentRow/ROW_RATE);
    }

    var newTextIndex = rocket_textIndex.getValue(currentRow);

    if (newTextIndex != textIndex) animateText("text"+textIndex);

    textIndex = newTextIndex;

    if (sceneIndex == 0) {
        tuniform.iTime.value = rocket_effutime.getValue(currentRow);

        cameraPalaset.position.x = rocket_camerax.getValue(currentRow);
        cameraPalaset.position.y = rocket_cameray.getValue(currentRow);
        cameraPalaset.position.z = rocket_cameraz.getValue(currentRow);
        cameraPalaset.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraPalaset.rotation.y = rocket_camerary.getValue(currentRow);
        cameraPalaset.rotation.z = rocket_camerarz.getValue(currentRow);


        if (roseclone) { 
            var i = 0;

        var breaktime = rocket_effutime.getValue(currentRow);

            roseclone.material.displacementMap = tgTexture;
            roseclone.material.displacementScale = Math.max(0.0,1.0-breaktime*0.15);
            roseclone.material.displacementBias = 0.0;
            roseclone.material.displacementMap.needsUpdate = true;
            roseclone.material.needsUpdate = true;
            roseclone.rotation.z += delta*0.5;
        }
        bokehrose.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokehrose.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokehrose.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);

/*
        sphereMesh.position.z = 1.5;
        sphereMesh.position.y = 1.2;
        sphereMesh.position.x = -0.05;
*/
        composerPalaset.render(clock.getDelta());
//      renderer.render( scenePalaset, cameraPalaset );
    } else if (sceneIndex == 1) {
        scenePass.camera = cameraTolppa;
        scenePass.scene = sceneTolppa;

        var animTime = clamp(sceneTime*0.1,0.0,1.0);
        sphereMesh2.position.x = rocket_meshx.getValue(currentRow);
        sphereMesh2.position.y = rocket_meshy.getValue(currentRow);
        sphereMesh2.position.z = rocket_meshz.getValue(currentRow);
        sphereMesh2.rotation.y = rocket_meshr.getValue(currentRow);
        tuniform.iTime.value = millis;
        tuniform.iAlpha.value = rocket_mesha.getValue(currentRow);
        materialTolppa.opacity = THREE.Math.lerp(0.0,0.1,easeInOut(animTime));

        cameraTolppa.lookAt(new THREE.Vector3(0.0,0.05,0.5));

        cameraTolppa.position.x = noise.perlin3(millis,millis,millis)*0.004;
        cameraTolppa.position.y = noise.perlin3(millis,millis,millis)*0.002;
        cameraTolppa.position.z = noise.perlin3(millis,millis,millis)*0.003;
        composerTolppa.render(clock.getDelta());
        //renderer.render( sceneTolppa, cameraTolppa );

    } else if (sceneIndex == 2) {
        cameraTori.setTarget( 'poliistarget' );
        cameraTori.update();
        scenePass.camera = cameraTori;
        scenePass.scene = sceneTori;
        poliis.rotation.z = Math.abs(Math.cos(millis*0.1)*2.5)+Math.sin(millis*0.1)*0.1;

        cameraTori.position.x = rocket_camerax.getValue(currentRow);
        cameraTori.position.y = rocket_cameray.getValue(currentRow);
        cameraTori.position.z = rocket_cameraz.getValue(currentRow);

        cameraTori.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraTori.rotation.y = rocket_camerary.getValue(currentRow);
        cameraTori.rotation.z = rocket_camerarz.getValue(currentRow);
//        cameraTori.position.x=-2.5;
//        cameraTori.position.y=-20.5+millis*1.2;
//        cameraTori.position.z=-2.+Math.cos(millis)*3.;
//        cameraTori.rotation.x=Math.cos(millis*0.5)*0.5;
        spotLight_tori1.intensity = 1.0;
                spotLight_tori2.intensity = 1.0;
        bokeh.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);
        composerTori.render(clock.getDelta());

    } else if (sceneIndex == 3) {
        cameraHall.rotation.x = -1.6;
        scenePass.camera = cameraHall;
        scenePass.scene = sceneHall;
        cameraHall.position.x = rocket_camerax.getValue(currentRow);
        cameraHall.position.y = rocket_cameray.getValue(currentRow);
        cameraHall.position.z = rocket_cameraz.getValue(currentRow);
        cameraHall.rotation.x += rocket_camerarx.getValue(currentRow);
        cameraHall.rotation.y = rocket_camerary.getValue(currentRow);
        cameraHall.rotation.z = rocket_camerarz.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);

        var breaktime = rocket_effutime.getValue(currentRow);

        if (hallMeshes) {
            var i = 0;

            if (meshcopy == null) {
                meshcopy = true;
                hallMeshes.forEach(function(child) {
                    i++;
                    cposx[i] = child.position.x;
                    cposy[i] = child.position.y;
                    cposz[i] = child.position.z;
                });
            }

            i = 0;
            hallMeshes.forEach(function(child) {
                i++;
                child.position.x = cposx[i];
                child.position.y = cposy[i];
                child.position.z = cposz[i];
                child.position.x += Math.cos(breaktime*0.001+i*0.5)*breaktime;
                child.position.y += Math.sin(breaktime*0.001+i*0.4)*breaktime;
                child.position.z += Math.cos(breaktime*0.001+i*0.3)*breaktime;
            });
        }


        spotLight_hall1.position.z = Math.abs(Math.cos(millis*0.2)*2.);
        spotLight_hall1.position.x = 5.-Math.abs(Math.sin(millis*0.5)*5.);
        composerHall.render(clock.getDelta());

    }

    prevTime = millis;

    if(demoMode && audioElement.paused) {
        loader.innerHTML = "";
        document.getElementById("blocker").style.display = "none";
        audioElement.play();
    }

    if (!demoMode) {
        loader.innerHTML = "";
        document.getElementById("blocker").style.display = "none";
    }

    if (audioElement.paused === false) window.requestAnimationFrame(render);

}


function animateText(name) {
    var $el = $("." + name + ":first"), text = $.trim($el.text()),
        words = text.split(" "), html = "";

    for (var i = 0; i < words.length; i++) {
        html += "<span>" + words[i] + ((i+1) === words.length ? "" : " ") + "</span>";
    };

    window.leftpres = 0;


    $el.html(html).children().hide().each(function(i){
        window.leftpres = ((i*15) % 75);

        if (window.preve) { 
            window.preve.animate({ opacity: 0, top: "46%" }, 1000);
        }

        var value = 0x9F + Math.random() * 0x5F | 0;
        var grayscale = (value << 16) | (value << 8) | value;
        var color = '#' + grayscale.toString(16);

        if ($(this).html() == "<pause>") { } 
        else { $(this).delay((i*1200)).fadeIn(1000); $(this).css('left', leftpres + "%"); $(this).css('color', color); }
        window.preve = $(this);
        window.prevleftpres = window.leftpres;
    });
    var $el = $("."+name);
    $el.animate({opacity: 0.8});
    $el.find("span").promise().done(function(){
        if (window.preve) { 
            window.preve.animate({ opacity: 0, top: "46%" }, 1000);
        }
    });    
}

</script>
</head>

<body>
<script>
    window.addEventListener('load', function() {
        init();
        console.log("demo start");
    }, false);

</script>
<div id = "blocker" style = "width:100%; height: 100%; position:fixed; background-color: black;z-index: 5;"></div>

<div id = "loader" style = "position:fixed;left:0%;top:85%; color: white; font-size:48px; z-index: 6">loading data, please wait...</div>
<audio id="audio" style = "display:none" preload="auto">
    <source src="plz_u.ogg" id="oggSource" type="audio/ogg" />
    <source src="plz_u.mp3" id="mp3Source" type="audio/mpeg" />
</audio>
<p class = "text1">does it matter that much anyway <pause> <pause> <pause> when everything is exploding around you</p>
<p class = "text2">the whole world, ripping out the seams <pause> <pause> <pause> and collapsing inward on itself</p>
<p class = "text3">the thousands of pieces flying off <pause> <pause> <pause> into the unknown depths like shrapnel</p>
<p class = "text4">planting broken seeds <pause> <pause> <pause> growing mucous memberanes and oily leaves</p>

</body>
</html>
