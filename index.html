<html>
<head>
 <link rel="stylesheet" type="text/css" href="stylesheet.css">
<link href="https://fonts.googleapis.com/css?family=Nothing+You+Could+Do" rel="stylesheet">
<style type = "text/css">
canvas {
    z-index: 3; 
    transform-origin: 0 0;   
    transform: scale(2.0);
}

body {
  margin: 0px;
  overflow: hidden;
  font-family: 'Nothing You Could Do', cursive;
  line-height: 0.0;
  font-size:6em; 
}

p{
  z-index: 6;
  position:fixed;
  opacity: 0.0;
}

span{
  position:fixed;
  top:50%;

  z-index: 6;
  padding: 10px; 
  text-shadow: 2px 2px #8F96A9; 
  color: #C1C5CF; 
}

.background {
  background: #343F61;
}

.underline {
  text-decoration: underline;
}
 
</style>
<script src = "jquery-3.2.1.min.js"></script>
<script src = "three.min.js"></script>
<script src = "postprocessing.js"></script>
<script src = "ColladaLoader.js"></script>
<script src = "TargetCamera.js"></script>
<script src = "GLTFLoader.js"></script>
<script src = "TexGen.js"></script>
<script src = "subdiv.js"></script>
<script src = "ShaderExtras.js"></script>
<script src = "SPE.js"></script>
<script src = "perlin.js"></script>
<script src = "jsRocket.js"></script>
<script src = "syncdata.js"></script>
<script src = "synctrack.js"></script>
<script src = "syncdeviceplayer.js"></script>
<script src = "syncdeviceclient.js"></script>
<script src = "syncdevice.js"></script>

<script id = "vertexShader" type = "glsl">

varying vec2 vUv; 

void main()
{
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id = "fragmentBranch" type = "glsl">
uniform vec2 iResolution;
uniform vec2 iMouse;
uniform float iTime;
uniform float iAlpha;
varying vec2 vUv;

#define kmarchMaxIter 32
#define ENABLE_AMBIENT_OCCLUSION
#define DOUBLE_SIDED_TRANSPARENCY


#define ENABLE_SPECULAR
#define ENABLE_REFLECTIONS
#define ENABLE_TRANSPARENCY
#define ENABLE_SHADOWS
#define ENABLE_FOG

#define ENABLE_DIRECTIONAL_LIGHT
#define ENABLE_DIRECTIONAL_LIGHT_FLARE

#define ENABLE_POINT_LIGHT
#define ENABLE_POINT_LIGHT_FLARE


struct Ray{
 vec3 origin;
 vec3 dir;
 float startdist;
 float len;
};

struct CollisionInfo{
 vec3 pos;
 float dist;
 vec3 id;
};
 
struct SurfInteraction{
 vec3 normal;
 vec3 reflection;
 vec3 transmission;  
};

struct Mat{
 vec3 albedo;
 float reflec;
 float smoothnes;
 vec2 param;

 float alpha;
 float reflecpow;
};

struct Shading{
 vec3 diffuse;
 vec3 specular;
};

struct PointLight{
 vec3 pos;
 vec3 color;
};

struct DirectionalLight{
 vec3 dir;
 vec3 color;
};


float inWater;
float wasInWater;

const float PImath = 3.141592654;
const float TAUmath = PImath * 2.0;

float NotTrancparent = -1.0;
float IsTransparent = 1.0;
float NegativeTransparency = 0.0;

mat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }
float rand(vec2 co){
 return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
float rand(float co){
 return rand(vec2(co));
}
float smin( float a, float b, float k ) {
 float res = exp( -k*a ) + exp( -k*b );
 return -log( res )/k;
}
float sdSphere( vec3 p, float s ){
return length(p)-s;
}
float udRoundBox( vec3 p, vec3 b, float r ) {
return length(max(abs(p)-b,0.0))-r;
}
float udBox( vec3 p, vec3 b ){
return length(max(abs(p)-b,0.0));
}
float sdBox( vec3 p, vec3 b ){
vec3 d = abs(p) - b;
return min(max(d.x,max(d.y,d.z)),0.0) +
    length(max(d,0.0));
}
float sdHexPrism( vec3 p, vec2 h ){
 vec3 q = abs(p);
 q=q.zxy;
 return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);
}

float length2( vec2 p ) {
 return sqrt( p.x*p.x + p.y*p.y );
}

float length6( vec2 p ) {
 p = p*p*p; p = p*p;
 return pow( p.x + p.y, 1.0/6.0 );
}

float length8( vec2 p ) {
 p = p*p; p = p*p; p = p*p;
 return pow( p.x + p.y, 1.0/8.0 );
}
float sdTorus88( vec3 p, vec2 t ){
vec2 q = vec2(length8(p.xz)-t.x,p.y);
return length8(q)-t.y;
}
float sdTorus82( vec3 p, vec2 t ){
vec2 q = vec2(length2(p.xz)-t.x,p.y);
return length8(q)-t.y;
}
float sdCappedCylinder( vec3 p, vec2 h ){
vec2 d = abs(vec2(length(p.xz),p.y)) - h;
return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
float sdCapsule( vec3 p, vec3 a, vec3 b, float r ){
 vec3 pa = p - a, ba = b - a;
 float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
 return length( pa - ba*h ) - r;
}
mat3 rotationMatrix(vec3 axis, float angle) {
 axis = normalize(axis);
 float s = sin(angle);
 float c = cos(angle);
 float oc = 1.0 - c;
 
 return mat3(oc * axis.x * axis.x + c,      oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,
       oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,      oc * axis.y * axis.z - axis.x * s,
       oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);
}

vec4 DistCombineUnion( in vec4 v1, in vec4 v2 ){
 //if(v1.x < v2.x) return v1; else return v2;
 return mix(v1, v2, step(v2.x, v1.x));
}

vec4 DistCombineUnionTransparent( in vec4 v1, in vec4 v2, in float transparencystate ){ 
 vec4 vScaled = vec4(v2.x * (transparencystate * 2.0 - 1.0), v2.yzw);
 return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, transparencystate));
}

vec4 DistCombineIntersect( in vec4 v1, in vec4 v2 ){
 return mix(v2, v1, step(v2.x,v1.x));
}

vec4 DistCombineSubtract( in vec4 v1, in vec4 v2 ){
 return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}

float kMatIdWall = 1.0;
float kMatIdRock = 2.0;
float kMatIdWater = 3.0;
float Noise(vec2 p){
 vec2 s = sin(p * 0.6345) + sin(p * 1.62423);
 return dot(s, vec2(0.125)) + 0.5;
}
vec2 hash( vec2 p ){
 p = vec2( dot(p,vec2(127.1,311.7)),
      dot(p,vec2(269.5,183.3)) );

 return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float perlinnoise( in vec2 p ){
  float K1 = 0.366025404; // (sqrt(3)-1)/2;
  float K2 = 0.211324865; // (3-sqrt(3))/6;

 vec2 i = floor( p + (p.x+p.y)*K1 );
 
 vec2 a = p - i + (i.x+i.y)*K2;
 vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
 vec2 b = a - o + K2;
 vec2 c = a - 1.0 + 2.0*K2;

 vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );

 vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));

 return dot( n, vec3(70.0) );
 
}

#define FAR 23.

 float hash12(vec2 p)
 {
   vec3 p3 = fract(vec3(p.xyx) * .1031);
   p3 += dot(p3, p3.yzx + 19.19);
   return fract((p3.x + p3.y) * p3.z);
 }

 float celli(in vec3 p) { p = fract(p) - .5; return dot(p, p); }

 float cellTile(in vec3 p) {
   vec4 d;
   d.x = celli(p - vec3(.81, .62, .53));
   p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;
   d.y = celli(p - vec3(.39, .2, .11));
   p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;
   d.z = celli(p - vec3(.62, .24, .06));
   p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;
   d.w = celli(p - vec3(.2, .82, .64));
   d.xy = min(d.xz, d.yw);
   return min(d.x, d.y)*2.66;
 }

 float hex(vec2 p) {
   p.x *= 0.57735*2.0;
   p.y += mod(floor(p.x), 2.0)*0.5;
   p = abs((mod(p, 1.0) - 0.5));
   return abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);
 }

 float cellTile2(in vec3 p) {
   vec4 d;
   d.x = celli(p - vec3(.81, .62, .53));
   p.xy = vec2(p.y - p.x, p.y + p.x) + hex(p.xy*0.2);
   d.y = celli(p - vec3(.39, .2, .11));
   p.yz = vec2(p.z - p.y, p.z + p.y) + hex(p.yz*0.2);
   d.z = celli(p - vec3(.62, .24, .06));
   p.xz = vec2(p.z - p.x, p.z + p.x) + hex(p.xz*0.2);
   d.w = celli(p - vec3(.2, .82, .64));
   d.xy = min(d.xz, d.yw);
   return min(d.x, d.y)*0.5;
 }

vec4 getSDF( in vec3 pos, in float transparencystate ){     
 vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);
 float lind=vResult.x;
 float distfWater = sdSphere(pos,4.0);
 vec3 pos1 = pos + iTime;
 vec3 pos2 = pos + iTime * 0.2321;
 float dFloor = sdBox(pos+vec3(0.0,7.0 + 50./(1.+ 2. * length(pos)),0.0),vec3(111.0,3.4+cellTile2(pos1/3.)+cellTile2(pos2/5.),111.0)); 
 for(float i=0.; i<14.; i++) {
   float fti = mod(i + floor(iTime + rand(iTime)) + 0.,14.);
   float ftj = mod(i + floor(iTime + rand(iTime)) + 1.,14.);
   vec3 a = vec3( rand(vec2(fti,4.3))-0.5, rand(vec2(fti,7.0))-0.5, rand(vec2(fti,0.0))-0.5) * 18.;
   vec3 b = vec3( rand(vec2(ftj,4.3))-0.5, rand(vec2(ftj,7.0))-0.5, rand(vec2(ftj,0.0))-0.5) * 18.;
     if(i<8.)
   lind = min(lind,sdCapsule( 
     pos, 
     vec3( rand(vec2(fti,4.3))-0.5, rand(vec2(fti,7.0))-0.5, rand(vec2(fti,0.0))-0.5) * 18.,
     vec3( rand(vec2(ftj,4.3))-0.5, rand(vec2(ftj,7.0))-0.5, rand(vec2(ftj,0.0))-0.5) * 18.,
     0.1 ));
   dFloor = min(dFloor,sdSphere(pos-a,0.4));
   dFloor = min(dFloor,sdSphere(pos-b,0.4));
 }
 vec4 vDistRock = vec4(lind, kMatIdRock, pos.xz + vec2(pos.y, 0.0)); 
 vResult = DistCombineUnion(vResult, vDistRock);  
 
 
 
 float dBrick = dFloor;
 
 vec4 vDistFloor = vec4(dBrick, kMatIdWall, pos.xz + vec2(pos.y, 0.0)); 
 vResult = DistCombineUnion(vResult, vDistFloor);  
 if(inWater==1.)
   distfWater = max(-distfWater,sdBox(pos,vec3(11111.)));  
 vec4 vDistWater = vec4(distfWater, kMatIdWater, pos.xy);  
 //if(inWater==0.)
 vResult = DistCombineUnionTransparent(vResult, vDistWater, transparencystate);
      
 return vResult;
}
Mat getmaterial( in CollisionInfo hitCase ) {
  Mat mat;
      
 if(hitCase.id.x == kMatIdWall) {
   mat.reflec = 0.1;
   mat.reflecpow = 1.0 / 1.3330;
   vec3 pos=hitCase.pos;
   mat.smoothnes = 0.18;
   mat.albedo = vec3(.3);
   mat.alpha = 0.0;
 }
 else if(hitCase.id.x == kMatIdRock) {
   mat.reflec = 0.0;
   mat.smoothnes = 0.0;
   mat.albedo = vec3(1.5);
   mat.alpha = 0.0;
 }
 else {
   mat.reflec = 0.1;
   mat.reflecpow = 1.0 / 1.3330;
   vec3 pos=hitCase.pos;
   mat.smoothnes = 0.9;
   vec3 rotpos = pos * rotationMatrix(vec3(perlinnoise(vec2(iTime,0.0)),perlinnoise(vec2(iTime,12.0)),perlinnoise(vec2(iTime,7.0))), iTime) ;
   mat.albedo = vec3(1.)*(1.-floor(mod(atan(rotpos.x,rotpos.z)*3.,1.1)))*(1.-floor(mod(rotpos.y,1.1)));
   mat.albedo = max(mat.albedo,vec3(0.));
   mat.alpha = 0.96;
 }
 
 return mat;
}

PointLight getPOINTLIGHT(){
  PointLight res;

 res.pos = vec3(0.0,0.0,0.0);
 res.color = vec3(311.,111.0,44.0);

 return res;
}

DirectionalLight getDIRLIGHT(){
  DirectionalLight res;

 res.dir = normalize(vec3(iMouse.x/iResolution.x-0.5,-0.2,iMouse.y/iResolution.y-0.5));
 res.color = vec3(4.0,6.4,9.4);

 return res;
}
vec3 getnormal( in vec3 pos, in float transparencystate ){
  float deltaval = 0.025;

 vec3 offsetvec1 = vec3( deltaval, -deltaval, -deltaval);
 vec3 offsetvec2 = vec3(-deltaval, -deltaval, deltaval);
 vec3 offsetvec3 = vec3(-deltaval, deltaval, -deltaval);
 vec3 offsetvec4 = vec3( deltaval, deltaval, deltaval);

 float f1 = getSDF( pos + offsetvec1, transparencystate ).x;
 float f2 = getSDF( pos + offsetvec2, transparencystate ).x;
 float f3 = getSDF( pos + offsetvec3, transparencystate ).x;
 float f4 = getSDF( pos + offsetvec4, transparencystate ).x;

 vec3 normal = offsetvec1 * f1 + offsetvec2 * f2 + offsetvec3 * f3 + offsetvec4 * f4;

 return normalize( normal );
}

#define epsilon 0.01
void march( in Ray ray, out CollisionInfo res, float transparencystate ){    
 CollisionInfo resorgi = res;
 res.dist = ray.startdist;
 res.id.x = 0.0;
 for(int i=0;i<=kmarchMaxIter;i++)       
 {
   res.pos = ray.origin + ray.dir * res.dist;
   vec4 vSceneDist = getSDF( res.pos, transparencystate );
   
   if(inWater == 0. && (i < 1) && (vSceneDist.y == kMatIdWater) && (vSceneDist.x < 0.01)) {
     inWater = 1.;
     wasInWater = inWater;
   } else {
     res.id = vSceneDist.yzw;
     res.dist = res.dist + vSceneDist.x; 
   }
 }
 if(res.dist >= ray.len)
 {
   res.dist = 1000.0;
   res.pos = ray.origin + ray.dir * res.dist;
   res.id.x = 0.0;
 }
}

void insidemarch( in Ray ray, out CollisionInfo res, float transparencystate ){    
 res.dist = ray.startdist;
 res.id.x = 0.0;
   
 for(int i=0;i<=kmarchMaxIter/3;i++)       
 {
   res.pos = ray.origin + ray.dir * res.dist;
   vec4 vSceneDist = getSDF( res.pos, transparencystate );
   res.id = vSceneDist.yzw;
   
   res.dist = res.dist + vSceneDist.x; 
   if(vSceneDist.y != kMatIdWater)
     return;
 }


 if(res.dist >= ray.len)
 {
   res.dist = 1000.0;
   res.pos = ray.origin + ray.dir * res.dist;
   res.id.x = 0.0;
 }
}

float traceToLight(vec3 raypos, vec3 normal, vec3 lightDir, float raylightdist) {

 vec3 ro = raypos;
 vec3 rd = lightDir;
 float t = 0.1;
 float k = raylightdist;
 float res = 1.0;
 for( int i=0; i<12; i++ )
 {
   float h = getSDF(ro + rd*t, IsTransparent).x;
   h = max( h, 0.0 );
   res = min( res, k*h/t );
   t += clamp( h, 0.001, 0.9 );
 }
 return clamp(res,0.1,9.0);
}
float getShadow( in vec3 pos, in vec3 normal, in vec3 lDir, in float lightdist ){
 return traceToLight(pos, normal, lDir, lightdist);
    Ray shadowRay;
   shadowRay.dir = lDir;
   shadowRay.origin = pos;
    float shadowbias = 0.05;
   shadowRay.startdist = shadowbias / abs(dot(lDir, normal));
   shadowRay.len = lightdist - shadowRay.startdist;
 
    CollisionInfo shadowIntersect;
   march(shadowRay, shadowIntersect, IsTransparent);
   
   float fShadow = step(0.0, shadowIntersect.dist) * step(lightdist, shadowIntersect.dist );
   
   return fShadow * traceToLight(pos, normal, lDir, lightdist);     
}

#define fogdensity 0.02

void skybox(inout vec3 col, in Ray ray, in CollisionInfo hitCase){
 float fogamount = exp(hitCase.dist * -fogdensity*(1.0+wasInWater));
 vec3 fogcolor = vec3(0.);

  DirectionalLight dirlight = getDIRLIGHT();
 float dirdot = clamp(dot(-dirlight.dir, ray.dir), 0.0, 1.0);
 fogcolor += dirlight.color * pow(dirdot, 20.0);

 col = mix(fogcolor, col, fogamount);

  PointLight pointlight = getPOINTLIGHT();

 vec3 lightdirec = pointlight.pos - ray.origin;
 float pointdoted = dot(lightdirec, ray.dir);
 pointdoted = clamp(pointdoted, 0.0, hitCase.dist);

 vec3 closest = ray.origin + ray.dir * pointdoted;
 float d = length(closest - pointlight.pos);
 col += pointlight.color * 0.01/ (d * d);
}

float schlick( in vec3 halfv, in vec3 view, in float reflec, in float smoothnes){
 float ddot = dot(halfv, -view);
 ddot = clamp((1.0 - ddot), 0.0, 1.0);
 float dotpowed = pow(ddot, 5.0121);
 return reflec + (1.0 - reflec) * dotpowed * smoothnes;
}

vec3 setFresnel( in vec3 diffuse, in vec3 specular, in vec3 normal, in vec3 view, in Mat material){
 vec3 ref = reflect(view, normal);
 vec3 halfv = normalize(ref + -view);
 float fresnel = schlick(halfv, view, material.reflec, material.smoothnes * 0.9 + 0.1);
 return mix(diffuse, specular, fresnel);  
}

float blinnphong( in vec3 iDir, in vec3 lDir, in vec3 normal, in float smoothnes){     
 vec3 halfv = normalize(lDir - iDir);
 float ndoth = max(0.0, dot(halfv, normal));

 float specPow = exp2(4.1 + 6.3 * smoothnes);
 float specularintensity = (specPow + 2.0321) * 0.12521;

 return pow(ndoth, specPow) * specularintensity;
}

Shading setPOINTLIGHT( in PointLight light, in vec3 pos, in vec3 iDir, in vec3 normal, in Mat material ){
  Shading shading;
 
 vec3 lightdirec = light.pos - pos;
 vec3 lDir = normalize(lightdirec);
 float lightdist = length(lightdirec);
 
 float lightattenuation = 1.0 / (lightdist * lightdist);
 
 float shadowfac = getShadow( pos, normal, lDir, lightdist );
 vec3 collisionsLight = light.color * max(0.0, shadowfac * lightattenuation * dot(lDir, normal)/(1.0+material.alpha));
 
 shading.diffuse = collisionsLight;                 
 shading.specular = blinnphong( iDir, lDir, normal, material.smoothnes ) * collisionsLight;
 
 return shading;
} 

Shading setDIRLIGHT( in DirectionalLight light, in vec3 pos, in vec3 iDir, in vec3 normal, in Mat material ){
  Shading shading;

  float shadowlen = 10.0;   
 vec3 lDir = -light.dir;
 float shadowfac = getShadow( pos, normal, lDir, shadowlen );
 vec3 collisionsLight = light.color * shadowfac * max(0.0, dot(lDir, normal)/(1.0+material.alpha));
 
 shading.diffuse = collisionsLight ;                 
 shading.specular = blinnphong( iDir, lDir, normal, material.smoothnes ) * collisionsLight;
 
 return shading;
} 


vec3 surfacelighting( in Ray ray, in CollisionInfo hitCase, in SurfInteraction surface, in Mat material){
 vec3 scenecol;
 
  Shading shading;

 shading.diffuse = vec3(0.0);
 shading.specular = vec3(0.0);
 
 float AO = 1.;
 vec3 ambiance = vec3(AO);
 
 shading.diffuse += ambiance;
 shading.specular += surface.reflection;
      
  PointLight pointlight = getPOINTLIGHT(); 
  Shading pointlighting = setPOINTLIGHT(pointlight, hitCase.pos,ray.dir, surface.normal, material);
 shading.diffuse += pointlighting.diffuse;
 shading.specular += pointlighting.specular;

  DirectionalLight dirlight = getDIRLIGHT();
  Shading directionLighting = setDIRLIGHT(dirlight, hitCase.pos, ray.dir, surface.normal, material);
 shading.diffuse += directionLighting.diffuse;
 shading.specular += directionLighting.specular;


 vec3 diffusereflection = shading.diffuse * material.albedo * ( 1.0 - material.alpha);       

 diffusereflection = mix(diffusereflection, surface.transmission, material.alpha);  

 scenecol = setFresnel(diffusereflection , shading.specular, surface.normal, ray.dir, material);
 
 return scenecol;
}

vec3 secondmarch( in Ray ray );

vec3 getreflection( in Ray ray, in CollisionInfo hitCase, in SurfInteraction surface ){
    float separation  = 0.1;

    Ray reflectRay;
   reflectRay.dir = reflect(ray.dir, surface.normal);
   reflectRay.origin = hitCase.pos;
   reflectRay.len = 16.0;
   reflectRay.startdist = separation / abs(dot(reflectRay.dir, surface.normal));
   
   return secondmarch(reflectRay);   
}

vec3 gettransmission( in Ray ray, in CollisionInfo hitCase, in SurfInteraction surface, in Mat material ){
 inWater = 0.;

    float separation = 0.05;
   Ray refractedray;
   refractedray.dir = refract(ray.dir, surface.normal, material.reflecpow);
   refractedray.origin = hitCase.pos;
   refractedray.len = 16.0;
   refractedray.startdist = separation / abs(dot(refractedray.dir, surface.normal));
      CollisionInfo hitCase2;
     insidemarch(refractedray, hitCase2, NegativeTransparency);
     vec3 normal = getnormal(hitCase2.pos, NegativeTransparency);
      Ray refractedray2;
     refractedray2.dir = refract(refractedray.dir, normal, 1.0 / material.reflecpow);
     refractedray2.origin = hitCase2.pos;
     refractedray2.len = 16.0;
     refractedray2.startdist = 0.0;
     
     float extinctiondistance = hitCase2.dist;
     float nontransparencity = 1.0 - material.alpha / (1.0+ distance(hitCase2.pos,hitCase.pos)*4. );
   
     vec3 sceneres = material.albedo * secondmarch(refractedray2) * nontransparencity ;
   
               
   vec3 materialExtinction = material.albedo;
   vec3 extinction = (1.7 / (1.0 + (materialExtinction * extinctiondistance)));   
   
               
   return sceneres * extinction;
}

vec3 secondmarch( in Ray ray ){
 CollisionInfo hitCase;
 inWater = 0.;
 march(ray, hitCase, NotTrancparent);
           
 vec3 scenecol;

 if(hitCase.id.x < 0.5)
 {
   scenecol = vec3(0.0);
 }
 else
 {
   SurfInteraction surface;    
   surface.normal = getnormal(hitCase.pos, NotTrancparent);
   Mat material = getmaterial(hitCase);
   surface.reflection = vec3(0.0);
   material.alpha = 0.0;
   scenecol = surfacelighting(ray, hitCase, surface, material);
 }

 skybox(scenecol, ray, hitCase);

 return scenecol;
}
vec3 colinfo;
vec3 firstmarch( in Ray ray ){                             
  CollisionInfo colpos;
 march(ray, colpos, IsTransparent);
   vec3 scenecol;

   if(colpos.id.x < 0.5) {
     scenecol = vec3(0.0);
   } else {
     SurfInteraction surface;
    
      float tSize1 = 1./2.;
     surface.normal = getnormal(colpos.pos, IsTransparent);
    
     Mat material = getmaterial(colpos);

     surface.reflection = getreflection(ray, colpos, surface);
     float disttrans = colpos.dist;
     if(material.alpha > 0.0) {  
       surface.transmission = gettransmission(ray, colpos, surface, material);
     }

     scenecol = surfacelighting(ray, colpos, surface, material);
   }
   colinfo = colpos.pos;
   skybox(scenecol, ray, colpos);
 return scenecol;
}

float farclip = 64.0;

void camray( in vec3 pos, in vec3 forwrd, in vec3 worlduo, in vec2 fragCoord, out Ray ray){
 vec2 UV = ( fragCoord.xy / iResolution.xy );
 vec2 vcoord = UV * 2.0 - 1.0;

 float ratio = iResolution.x / iResolution.y;
 vcoord.y /= ratio;             

 ray.origin = pos;

 vec3 rightv = normalize(cross(forwrd, worlduo));
 vec3 upv = cross(rightv, forwrd);
   
 ray.dir = normalize( rightv * vcoord.x + upv * vcoord.y + forwrd) ; 
 ray.startdist = 0.0;
 ray.len = farclip;   
}

void lookAtCam( in vec3 pos, in vec3 interest, in vec2 fragCoord, out Ray ray){
 camray(pos, normalize(interest - pos), vec3(0.0, 1.0, 0.0), fragCoord, ray);
}
vec3 tmap( in vec3 colour ){ 
 return 1.0 -exp2(-colour);
}
void main(){
 Ray ray;
 inWater = 0.;
 vec2 fragCoord = vUv * iResolution.xy;
 vec2 uv = fragCoord.xy / iResolution.xy;
 vec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;
 vec3 lookAt = vec3(-3.0, 1.0, 3.0);
 vec3 ro = vec3(24.0*sin(1.2)+5.,14.0,24.0*cos(1.2));
 ro.x-=iTime*5.;
 lookAtCam( ro, lookAt, fragCoord, ray);
 vec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;
 float rf2_1 = sqrt(dot(coord, coord)) * 0.2 * sqrt(dot(coord, coord)) * 0.2 + 1.0;
 gl_FragColor = vec4( 1.2 / (rf2_1 * rf2_1)*tmap(firstmarch( ray ) * 1.5), distance(ro,colinfo) );
}
</script>



<script id = "fragmentTolppa" type = "glsl">
uniform float iTime;
uniform float iAlpha;
varying vec2 vUv;

float NEAR_CLIPPING_PLANE=.005;
float FAR_CLIPPING_PLANE=20.;
int NUMBER_OF_MARCH_STEPS=500;
float EPSILON=.1;
float DISTANCE_BIAS=.3;
float t = 0.;

float sdSphere(vec3 p, float s)
{
    return length(p) - (s);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float fOpUnionRound(float a, float b, float r) {
    vec2 u = max(vec2(r - a,r - b), vec2(0));
    return max(r, min (a, b)) - length(u);
}


float scene(vec3 pos)
{
    vec3 translate1 = vec3(-0.1, fract(pos.y*clamp(iTime*0.05,0.,1.0)), 0.);
    vec3 translate2 = vec3(0.0,distance(1.+abs(cos(pos.x*0.1+cos(iTime*0.1+pos.z+pos.x)*0.5)*10.),pos.y-8.+cos(pos.z)),cos(pos.x+iTime));

    vec3 translate = translate2;

    vec3 opos = pos - translate;

    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.001+cos(pos.x*1.1)*0.1)*0.2)*3.91;

    return finalDist;
}

vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.;
    for(int i = 0 ; i < 500 ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        float result = scene(pos);
        acc+=result*0.2;

        if(result < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result * DISTANCE_BIAS;
                
        if(total_distance > FAR_CLIPPING_PLANE) return vec2(0.0,-1.0);
    }
    return vec2(0.0,-1.0);
}

vec3 nr(vec3 n) {
    return normalize(n);
}

vec3 normal( in vec3 pos )
{
    vec3 eps = vec3(.3,0.,0.)*EPSILON;
    vec3 nor = vec3(
        scene(pos+eps.xyy) - scene(pos-eps.xyy),
        scene(pos+eps.yxy) - scene(pos-eps.yxy),
        scene(pos+eps.yyx) - scene(pos-eps.yyx) );
    return nr(nor);
}



float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1., max(NdotL, NdotV), step(0., s));

  float sigma2 = roughness * roughness;
  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));
  float B = .45 * sigma2 / (sigma2 + .09);

  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;
}

void main() {
    // pixel coordinates
    vec2 uv = -1.0 + 2.0 * vUv;
    
    vec3 direction = nr(vec3(uv, 0.));

    t = iTime*0.5;

    float cz = t*5.9;
    

    float FOV = 10.0;
        
        vec3 camera_origin = vec3(0., 1., cz);
    vec3 lookAt = vec3(0.0,2.,cz+1.);
    
    vec3 forward = nr(lookAt-camera_origin);
    vec3 right = nr(vec3(forward.z, 0., -forward.x ));
    vec3 up = nr(cross(forward,right));

    
    vec3 ro = camera_origin;
    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    if (result.y == -1.0) gl_FragColor = vec4(0.0,0.0,0.0,0.0);
    else {
        float fog = pow(1. / (1. + result.x), .2);
        
        vec3 materialColor = vec3(1.3-result.x*.01*.5,.9,1.*.5)*0.2;
        vec3 intersection = ro + rd*result.x;
        
        vec3 nrml = normal(intersection);
        vec3 light_dir = nr(vec3(0.,.0,-1.));
        vec3 ref = reflect( rd, nrml );

        float dom = smoothstep( -.1, .9, ref.y);
        float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);

        float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.0,0.5)-result.y*.05;
        
        vec3 light_color = vec3(1.);
        vec3 ambient_color = light_color;
        vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
        vec3 outColor = diffuseLit*fog+dom*.2+spe*.5;
        gl_FragColor = vec4(outColor,iAlpha*(1.0-distance(0.5,result.x)*.1));
    }
 }
</script>

<script id = "fragmentPink" type = "glsl">
uniform float iTime;
uniform float iAlpha;
varying vec2 vUv;

float NEAR_CLIPPING_PLANE=0.1;
float FAR_CLIPPING_PLANE=200.;
int NUMBER_OF_MARCH_STEPS=200;
float EPSILON=0.05;
float DISTANCE_BIAS=.15;
float t = 0.;

float sdSphere(vec3 p, float s)
{
    return length(p) - (s+cos(p.z)*0.1);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float fOpUnionRound(float a, float b, float r) {
    vec2 u = max(vec2(r - a,r - b), vec2(0));
    return max(r, min (a, b)) - length(u);
}


vec3 opRepeat(vec3 p, vec3 c){
  return p-c*floor(p/c)-0.5*c;
}

float scene(vec3 pos)
{
    vec3 translate = vec3(cos(pos.z)*0.1,distance(cos(pos.z+t*10.)*0.1,pos.y)*0.5, t*2.+cos(pos.x));
    pR(pos.xy,cos(pos.z)*cos(pos.z));
    vec3 opos = pos - translate;    
    t = pos.z*0.1+cos(pos.z*0.1)*0.5;
    pos.xy*=cos(pos.x*0.1)*sin(pos.z*0.1)*5.;
    vec3 rr = vec3(pos.x*cos(t*0.1+pos.z*0.1),(20.0+t)*0.1+distance(cos(pos.x)*1.5,sin(pos.z))*0.5,2.);
    vec3 rr2 = vec3(pos.z*sin(t*0.1+pos.z*0.2),(40.0+t)*0.1+distance(sin(pos.y)*0.5,sin(pos.y))*0.5,2.);
    float finalDist = sdSphere(opRepeat(opos,rr+cos(pos.z)*0.1),abs(cos(pos.z+t)*1.));
    float finalDist2 = sdSphere(opRepeat(opos,rr2),abs(sin(pos.z+t)*1.))*0.2;
    finalDist = fOpUnionRound(finalDist,finalDist2,cos(pos.z*2.1+t*0.1)*1.5);
    
    return finalDist;
}


vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.;
    for(int i = 0 ; i < 200 ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        float result = scene(pos);
        acc+=cos(result*1.)*.05;

        if(result < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result * DISTANCE_BIAS;
        
        
        if(total_distance > FAR_CLIPPING_PLANE)
            break;
    }
    return vec2(FAR_CLIPPING_PLANE, acc);
}

vec3 nr(vec3 n) {
    return normalize(n);
}

vec3 normal( in vec3 pos )
{
    vec3 eps = vec3(.3,0.,0.)*EPSILON;
    vec3 nor = vec3(
        scene(pos+eps.xyy) - scene(pos-eps.xyy),
        scene(pos+eps.yxy) - scene(pos-eps.yxy),
        scene(pos+eps.yyx) - scene(pos-eps.yyx) );
    return nr(nor);
}



float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1., max(NdotL, NdotV), step(0., s));

  float sigma2 = roughness * roughness;
  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));
  float B = .45 * sigma2 / (sigma2 + .09);

  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;
}

void main() {
    // pixel coordinates
    vec2 uv = -1.0 + 2.0 * vUv;
    
    vec3 direction = nr(vec3(uv, 0.));

    t = iTime;

    t += iTime*1.*abs(cos(iTime*0.01));

    float cz = t+16.;
    

    float FOV = 0.5;
        
    vec3 camera_origin = vec3(0., 0.0, cz);
    vec3 lookAt = vec3(0.0,0.0,cz+1.);
    

    vec3 forward = nr(lookAt-camera_origin);
    vec3 right = nr(vec3(forward.z, 0., -forward.x ));
    vec3 up = nr(cross(forward,right));

    
    vec3 ro = camera_origin;
    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    float fog = pow(1. / (1. + result.x), 0.2);
            
    vec3 materialColor = vec3(0.5,1.0-result.x*0.06,1.0-result.x*0.03);
    vec3 intersection = ro + rd*result.x;
    
    vec3 nrml = normal(intersection);
    vec3 light_dir = nr(vec3(0.,0.0,-1.));
    vec3 ref = reflect( rd, nrml );

    float dom = smoothstep( -.1, .9, ref.y);
    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);

    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3,.3)-result.y*.06;

    float tumm = abs(1.0-result.x)*0.03;
    
    diffuse-=tumm;
    diffuse = clamp(diffuse,-1.0,0.0);
    
    vec3 light_color = vec3(1.);
    vec3 ambient_color = light_color;
    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;
    outColor*=1.0-tumm*0.3;
    gl_FragColor = vec4(outColor,1.0);
  }

</script>


<script id = "fragmentPalaset" type = "glsl">
uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
varying vec2 vUv;
float PI=3.14159;

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898+co.y,78.233+co.x))) * 5.*iTime*0.01+43758.5453);
}

float pix(vec2 uv){
    return step(0.5+uv.y*0.01+(cos(uv.x*0.01+10.*iTime*0.5)*0.001),rand(floor(uv)));    
}

float hm(vec2 uv){
    uv*=2.0;
    vec2 nuv = (fract(uv)-0.5)*4.;
    vec2 pos = sign(nuv)*0.4-distance(nuv.yx,uv.yx)*(cos(10.*iTime+nuv.x*nuv.y)*0.04);
    
    float d = length(nuv);
    
    float v = pix(uv);
    
    if(d>1.){
    
    vec2 p1=vec2(pos.x,0.),
         p2=vec2(0.,pos.y);
    
    float v1 = pix(uv+p1),
          v2 = pix(uv+p2);
    
        if(v1==v2){
            if(v==pix(uv+pos) && v!=v1) v=0.;
            else v=v1;
        }
    }   
    
    return mix(pix(uv),v,smoothstep(d,1.0,1.1));
}

vec3 shade(vec2 uv){
    uv*=5.;
    return vec3(hm(uv));
}

void main()
{
    vec2 uv = -1.0 + 2.0 * vUv*3.;
    if (uv.x < 0.0) uv.x = 0.0-uv.x;
    if (uv.y < 0.0) uv.y = 0.0-uv.y;
    
    vec3 color = shade(uv);
    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) discard;
    color.rgb*=texture2D(iChannel1,uv).rgb;
    color.rgb-=texture2D(iChannel0,uv+iTime*0.2).rgb*0.5;
    gl_FragColor = vec4(color*vec3(1.1,1.3,0.4),0.5);
}

</script>

<script src = "orbit.js"></script>
<script src = "quad.js"></script>

<script>

// Rose by cosmicollie is licensed under CC Attribution-NonCommercial
// polliisi by Juha M (from Sketchfab)
// time fuse by Skoklosters slott Time Fuse is licensed under CC Attribution-ShareAlike
// Abandoned Warehouse - Interior Scene(https://sketchfab.com/models/1d5285f2e0fd4211a27c8042496d5959) by AurÃ©lien Martel(https://sketchfab.com/aurelien_martel) is licensed under CC Attribution(http://creativecommons.org/licenses/by/4.0/)
// Bouquet de fleurs tropicales / new version (PBR) by Argos VR Systems is licensed under CC Attribution
// palloviivashader by branch, other shaders + main demo code & design by visy, music and design by zov, Quadtrip logo by Isildur^Samar
 
var camera;
var cameraPalaset, cameraTolppa, cameraTori, cameraHall, cameraBranch, cameraBranchEff, cameraPinkEff, scenePalaset, sceneTolppa, sceneTori, sceneHall, sceneTolppa2, sceneBranch;
var renderer;
var geometry, material, sphereMesh;
var tuniform, clock, audioElement;
var millis, sceneIndex, prevSceneIndex;
var screenQuad, sphereMesh2, sphereMesh3, sphereMesh4, composerTolppa, composerPalaset, composerTori, composerHall, composerBranch, materialTolppa, scenePass;
var syncReady = false;
var roseclone, rose, poliis, bokeh, bokehrose, bokehtori, bokehbranch, bokehtolppa;

var emitter1,particleGroup1;

var spotLight_tori2, spotLight_tori1;


var spotLight_hall1;
var tgTexture;
var rtTexture;
var materialBranch, materialPink;

var hallMeshes = new Array()

var fleurGroup = new THREE.Group();
var pilarGroup = new THREE.Group();

var bufferScene;
var bufferTexture;
var bufferScene2;
var bufferTexture2;


var filmTori, filmTolppa, filmHall, filmBranch, filmPalaset;


/////////////////////////

/////////////////////////

/////////////////////////

var demoMode = false;

/////////////////////////

/////////////////////////

/////////////////////////




var syncDevice,
    //Beats per minute of your demo tune
    BPM = 135,
    //The resolution between two beats, four is usually fine,- eight adds a bit more finer control
    ROWS_PER_BEAT = 8,
    //we calculate this now, so we can translate between rows and seconds later on
    ROW_RATE = BPM / 60 * ROWS_PER_BEAT,
    //your variable that needs tuning in Rocket
    rocket_meshx,
    rocket_meshy,
    rocket_meshz,
    rocket_meshr,
    rocket_mesha,
    rocket_camerax,
    rocket_cameray,
    rocket_cameraz,
    rocket_camerarx,
    rocket_camerary,
    rocket_camerarz,
    rocket_effutime,
    current_scene,
    rocket_aperture,
    rocket_dof,
    rocket_focus,
    rocket_textIndex,
    rocket_light1x,
    rocket_light1y,
    rocket_light1z,
    rocket_light1i,
    rocket_light2x,
    rocket_light2y,
    rocket_light2z,
    rocket_light2i,
    rocket_light3x,
    rocket_light3y,
    rocket_light3z,
    rocket_light3i,
    rocket_light4x,
    rocket_light4y,
    rocket_light4z,
    rocket_light4i,
    rocket_light5x,
    rocket_light5y,
    rocket_light5z,
    rocket_light5i,
    rocket_eye,
    //the current row we're on
    row = 0;


function initParticles() {
    particleGroup1 = new SPE.Group({
        texture: {
            value: THREE.ImageUtils.loadTexture('smokeparticle.png')
        },
        fog: true,
        scale: 30
    });

    emitter1 = new SPE.Emitter({
        type: SPE.distributions.BOX,
        maxAge: 20,
        position: {
            value: new THREE.Vector3(0, 0, 0),
            spread: new THREE.Vector3( 200, 30, 30 )
        },
        particleCount: 10000,
        isStatic: true
    });

    particleGroup1.addEmitter( emitter1 );
    sceneTori.add( particleGroup1.mesh );
}



var gltfcount = 0;
var allmodelscount = 4;
var audioInited = false;
// demo init

function addGLTFCount() {
    gltfcount++;
    console.log("gltfcount:" + gltfcount);

    var dd = document.getElementById("loader");
    loader.innerHTML = "loading model data (" +gltfcount+"/"+allmodelscount+")"; 
    if (gltfcount >= allmodelscount && !audioInited) {
    console.log("all models loaded");
        modelsdone();
    }
}

function modelsdone() {
    loader.innerHTML = "initializing demo";
    audioElement.oncanplaythrough = onAudioReady;
    setTimeout(function() { audioElement.load(); }, 200);

}

function loadModels() {
    var loadergltf = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf.load(
        // resource URL
        'rose.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();

            gltf.scene.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    child.castShadow = true;

                    roseclone = child.clone();
                    roseclone.position.z = 1.2;
                    roseclone.position.y = -0.6;
                    roseclone.rotation.x = -2.;
                    roseclone.scale.set(0.2,0.2,0.2);
                    scenePalaset.add(roseclone);

                    child.position.z = 4.7;
                    child.rotation.x = -0.9;
                    child.rotation.y = 1.1;
                    child.rotation.z = 1.5;
                    child.position.y = 3.5;
                    child.position.x = 8.;
                    child.scale.set(0.5,0.5,0.5);
                    rose = child;
                    sceneTori.add( child );                    
                }
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );


            addGLTFCount();


    var loadergltf4 = new THREE.GLTFLoader();

    // Load a glTF resource
    loadergltf4.load(
        // resource URL
        'time_fuse/scene.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();
            gltf.scene.traverse( function ( child ) {
//                if ( child instanceof THREE.Mesh ) {
                    child.position.x -= 2.;
                    child.position.y -= 0.;
                    child.position.z -= 24.;
                    child.rotation.x = 1.;
                    scenePalaset.add( child );            
//                    child.visible = false;
//                }
            });


/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );

    var loadergltf5 = new THREE.GLTFLoader();

    var tx1 = new THREE.TextureLoader().load("PBR_sign_baseColor2.png");
    var tx2 = new THREE.TextureLoader().load("PBR_sign_baseColor3.png");
    var tx3 = new THREE.TextureLoader().load("PBR_sign_baseColor4.png");
    var tx4 = new THREE.TextureLoader().load("PBR_sign_baseColor5.png");
    var tx5 = new THREE.TextureLoader().load("PBR_sign_baseColor6.png");
    var tx6 = new THREE.TextureLoader().load("PBR_sign_baseColor7.png");
    var tx7 = new THREE.TextureLoader().load("PBR_sign_baseColor8.png");
    var tx8 = new THREE.TextureLoader().load("PBR_sign_baseColor9.png");

    tx1.flipY = false;
    tx1.wrapS = THREE.RepeatWrapping;
    tx1.wrapT = THREE.RepeatWrapping;
    tx1.repeat.set( 1, 1 );

    tx2.flipY = false;
    tx2.wrapS = THREE.RepeatWrapping;
    tx2.wrapT = THREE.RepeatWrapping;
    tx2.repeat.set( 1, 1 );

    tx3.flipY = false;
    tx3.wrapS = THREE.RepeatWrapping;
    tx3.wrapT = THREE.RepeatWrapping;
    tx3.repeat.set( 1, 1 );

    tx4.flipY = false;
    tx4.wrapS = THREE.RepeatWrapping;
    tx4.wrapT = THREE.RepeatWrapping;
    tx4.repeat.set( 1, 1 );

    tx5.flipY = false;
    tx5.wrapS = THREE.RepeatWrapping;
    tx5.wrapT = THREE.RepeatWrapping;
    tx5.repeat.set( 1, 1 );

    tx6.flipY = false;
    tx6.wrapS = THREE.RepeatWrapping;
    tx6.wrapT = THREE.RepeatWrapping;
    tx6.repeat.set( 1, 1 );

    tx7.flipY = false;
    tx7.wrapS = THREE.RepeatWrapping;
    tx7.wrapT = THREE.RepeatWrapping;
    tx7.repeat.set( 1, 1 );

    tx8.flipY = false;
    tx8.wrapS = THREE.RepeatWrapping;
    tx8.wrapT = THREE.RepeatWrapping;
    tx8.repeat.set( 1, 1 );

    // Load a glTF resource
    loadergltf5.load(
        // resource URL
        'gltftest.gltf',
        // called when the resource is loaded
        function ( gltf ) {

            addGLTFCount();
            gltf.scene.traverse( function ( child ) {
                    console.log("-" + child.name + "-")
                    if (child.material) console.log("-" + child.material.map + "-")
                    for (i = 0; i < 8; i++) {
                        var clone = null;

                        if (child.name == "") {
                            var once = 0;
                            child.traverse( function ( child2 ) {
                                if (child2.material) {

                                    if (child2.material.name = "PBR sign") {
                                        once++;
                                        if (once == 8) {
                                            child2.material = child2.material.clone();
                                            if (i == 0) child2.material.map = tx1;
                                            if (i == 1) child2.material.map = tx2;
                                            if (i == 2) child2.material.map = tx3;
                                            if (i == 3) child2.material.map = tx4;
                                            if (i == 4) child2.material.map = tx5;
                                            if (i == 5) child2.material.map = tx6;
                                            if (i == 6) child2.material.map = tx7;
                                            if (i == 7) child2.material.map = tx8;
                                            child2.material.map.needsUpdate= true;
                                            child2.material.needsUpdate= true;
                                        } else {
                                            child2.material.aoMap = THREE.ImageUtils.loadTexture('pbrao1.png');
                                            child2.material.roughness = 0.1;
                                            child2.material.normalMap = THREE.ImageUtils.loadTexture('pbrnormal1.png');
                                            child2.material.needsUpdate= true;
                                        }

                                    } else {

                                    }                              
                                }
                                console.log(child2.material);
                            });
                        } 
                        clone = child.clone();
                        clone.receiveShadow = true;
                        clone.castShadow = true;
                        clone.position.z = 5;
                        clone.position.y = -9.0;
                        clone.position.x = -1+i*5;

                        clone.scale.set(0.02,0.02,0.02);
                        sceneTori.add(clone);

                        clone = child.clone();
                        clone.receiveShadow = true;
                        clone.castShadow = true;
                        clone.position.z = -5;
                        clone.position.y = -9.0;
                        clone.position.x = -1+i*5;

                        clone.scale.set(0.02,0.02,0.02);
                        sceneTori.add(clone);
                        
                    }
    //                if ( child instanceof THREE.Mesh ) {
    //                }
            });
/*
            var i = 0;
            for (i = 0; i < 8; i++) {
                var mesh = pilarGroup.clone();

                mesh.position.z = -5;
                mesh.position.x = -1+i*5;

                sceneTori.add(mesh);

                var mesh = pilarGroup.clone();
                mesh.position.z = 5;
                mesh.position.x = -1+i*5;
                sceneTori.add(mesh);
            } 
*/
/*
            gltf.animations; // Array&lt;THREE.AnimationClip&gt;
            gltf.scene; // THREE.Scene
            gltf.scenes; // Array&lt;THREE.Scene&gt;
            gltf.cameras; // Array&lt;THREE.Camera&gt;
*/
        },
        // called when loading is in progresses
        function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        },
        // called when loading has errors
        function ( error ) {

            console.log( 'An error happened:' + error );

        }
    );


    // museo

    var geometry = new THREE.BoxGeometry( 200, 30, 30);
    var tex = new THREE.TextureLoader().load("tex2.jpg");
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set( 12, 4 );
    tex.minFilter = THREE.LinearMipMapNearestFilter;
    tex.anisotropy = 4;

    var tex2 = new THREE.TextureLoader().load("tex1.jpg");
    tex2.wrapS = tex2.wrapT = THREE.RepeatWrapping;
    tex2.repeat.set( 12, 4 );
    tex2.minFilter = THREE.LinearMipMapNearestFilter;
    tex2.anisotropy = 4;

     var material = new THREE.MeshPhysicalMaterial({
            color: 0x252535,
            roughness: 0.9,
            metalness: 0.2,
            clearCoat: 0.9,
            clearCoatRoughness: 0.9,
            reflectivity: 0.8,
            bumpMap: tex,
            aoMap: tex2,
            bumpScale: 0.1,
            side: THREE.DoubleSide
    });

    var mesh = new THREE.Mesh( geometry, material );
    mesh.receiveShadow = true;
    mesh.position.z = 0;
    mesh.position.y = 13;
    sceneTori.add(mesh);




}


function init() {

    cameraPalaset = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.01, 100 );
    cameraTolppa = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        cameraPalaset.position.z = 0.2;
    cameraTori = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.001, 1000 );
    cameraHall = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.01, 100 );
    cameraBranch = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100 );
    cameraBranchEff = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100 );
    cameraPinkEff = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );

    window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize(){
        cameraPalaset.aspect = window.innerWidth / window.innerHeight;
        cameraPalaset.updateProjectionMatrix();
        cameraTolppa.aspect = window.innerWidth / window.innerHeight;
        cameraTolppa.updateProjectionMatrix();
        cameraTori.aspect = window.innerWidth / window.innerHeight;
        cameraTori.updateProjectionMatrix();

        cameraHall.aspect = window.innerWidth / window.innerHeight;
        cameraHall.updateProjectionMatrix();

        cameraBranch.aspect = window.innerWidth / window.innerHeight;
        cameraBranch.updateProjectionMatrix();
        cameraBranchEff.aspect = window.innerWidth / window.innerHeight;
        cameraBranchEff.updateProjectionMatrix();

        cameraPinkEff.aspect = window.innerWidth / window.innerHeight;
        cameraPinkEff.updateProjectionMatrix();


        if (renderer) renderer.setSize( window.innerWidth*0.5, window.innerHeight*0.5 );
    }

    prevSceneIndex = -1;
    sceneIndex = 1;

    clock = new THREE.Clock;
    scenePalaset = new THREE.Scene();
    sceneTolppa = new THREE.Scene();
    sceneTolppa2 = new THREE.Scene();
    sceneTori = new THREE.Scene();
    sceneHall = new THREE.Scene();
    sceneBranch = new THREE.Scene();

    var loader = new THREE.TextureLoader();
    
    tuniform = {
        iTime:          { value: 0.1 },
        iAlpha:         { value: 1.0 }, 
        iResolution:    { value: new THREE.Vector2() }, 
        iMouse:         { value: new THREE.Vector2() }, 
        iChannel0:      { value: loader.load( 'tex1.jpg') },
        iChannel1:      { value: loader.load( 'tex2.jpg' ) },
    };

    tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
    tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

    tuniform.iResolution.x = window.innerWidth*0.5;
    tuniform.iResolution.y = window.innerHeight*0.5;

    var materialPala = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentPalaset' ).textContent,
        side:THREE.DoubleSide,
        transparent: true,
    });


    materialTolppa = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentTolppa' ).textContent,
        transparent: true,
        side:THREE.DoubleSide,
    });

    materialPink = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentPink' ).textContent,
        transparent: true,
        side:THREE.DoubleSide,
    });

    materialBranch = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentBranch' ).textContent,
        transparent: false,
        side:THREE.DoubleSide,
    });

    geometry = new THREE.SphereGeometry( 0.2, 64, 64 );
    sphereMesh = new THREE.Mesh( geometry, materialPala );
    sphereMesh.receiveShadow = false;
    sphereMesh.castShadow = false;
//  scenePalaset.add( sphereMesh );

    var path = "bud/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube = new THREE.CubeTextureLoader().load( urls );
    cube.format = THREE.RGBFormat;


    var path = "horn/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube2 = new THREE.CubeTextureLoader().load( urls );
    cube2.format = THREE.RGBFormat;

    var i = 0;
    tgTexture = new TG.Texture(1024, 1024)
    .add( new TG.SinX().frequency( 0.066 + 0.05*Math.sin(1) ) )
    .add( new TG.SinY().frequency( 0.066 + 0.05*Math.sin(1) ) )
    .mul( new TG.SinX().offset( 25. ).frequency( 0.044 + 0.09*Math.sin(i/100) ).tint( 2, 2, 2 ) )
    .mul( new TG.SinY().offset( 16 ).frequency( 0.044 + 0.09*Math.sin(i/100) ).tint( 2, 2, 2 ) )
    .sub( new TG.Number().tint( 0.5, 2, 4. ) );

    tgTexture = new THREE.Texture(tgTexture.toCanvas());
    tgTexture.needsUpdate = true;

    loadModels();


    sceneTolppa.background = cube;
    scenePalaset.background = cube2;
    sceneHall.background = cube2;

    var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
    scenePalaset.add( light );
    var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
    sceneTori.add( light );
    var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
    sceneTolppa.add( light );
    var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
    sceneHall.add( light );

    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, -5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    scenePalaset.add(spotLight);

    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 10, 0);
    spotLight.castShadow = false;

    spotLight.intensity = 2.0;
    scenePalaset.add(spotLight);

    var spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(0, 1, 5);
    spotLight2.castShadow = false;
    spotLight2.intensity = 0.2;
    scenePalaset.add(spotLight2);

    spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(5, 10, -5);
    spotLight2.castShadow = false;
    spotLight2.intensity = 0.5;
    scenePalaset.add(spotLight2);

    var spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(1, 5, -100);
    spotLight2.castShadow = false;
    spotLight2.intensity = 2.0;
    sceneTolppa.add(spotLight2);

    spotLight_tori1 = new THREE.PointLight( 0xffffff, 1, 100 );
    spotLight_tori1.castShadow = false;
    spotLight_tori1.position.set( 0, 0, -5 );
    sceneTori.add( spotLight_tori1 );
    spotLight_tori2 = new THREE.PointLight( 0xffffff, 1, 100 );
    spotLight_tori2.castShadow = true;
    spotLight_tori2.position.set( 0, 0, 5 );
    sceneTori.add( spotLight_tori2 );

    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 5, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 1.0;
    sceneHall.add(spotLight);

    spotLight_hall1 = spotLight;

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(5, 0, 0);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, -5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(0, 0, 5);
    spotLight.castShadow = false;
    spotLight.intensity = 0.5;
    sceneHall.add(spotLight);

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( window.innerWidth*0.5, window.innerHeight*0.5 );
    renderer.setPixelRatio( window.devicePixelRatio*1.0 );
    renderer.setClearColor( 0x000000, 1);
    renderer.shadowMapEnabled = true;

    bufferScene = new THREE.Scene();
    bufferTexture = new THREE.WebGLRenderTarget( 320*2, 180*2, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter});
    bufferScene2 = new THREE.Scene();
    bufferTexture2 = new THREE.WebGLRenderTarget( 640, 360, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter});

    var pgeometry = new THREE.PlaneGeometry( 3.0, 1.7 );
    var mesh = new THREE.Mesh( pgeometry, materialBranch );
    mesh.position.z = -1;
    bufferScene.add(mesh);

    var pgeometry3 = new THREE.PlaneGeometry( 3, 2 );
    var mesh = new THREE.Mesh( pgeometry3, materialPink );
    mesh.position.z = -1;
    bufferScene2.add(mesh);

    var boxMaterial = new THREE.MeshBasicMaterial({map:bufferTexture.texture});
    var mainBoxObject = new THREE.Mesh(pgeometry,boxMaterial);
    mainBoxObject.position.z = -10;
    sceneBranch.add(mainBoxObject);

    var boxMaterial = new THREE.MeshBasicMaterial({map:bufferTexture2.texture});
    var mainBoxObject = new THREE.Mesh(pgeometry,boxMaterial);
    mainBoxObject.position.z = -10;
    sceneHall.add(mainBoxObject);


    sphereMesh2 = new THREE.Mesh( geometry, materialTolppa );

    sceneTolppa.add(sphereMesh2);

    sphereMesh3 = new THREE.Mesh( geometry, materialTolppa );
    sphereMesh3.position.y = 0;
    sphereMesh3.position.x = -5;
    sphereMesh3.scale.set(5.,5.,5.);
    sphereMesh3.rotation.z = 1.5;

    sceneTori.add(sphereMesh3);


    composerTolppa = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneTolppa, cameraTolppa)
    composerTolppa.addPass(scenePass);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerTolppa.addPass(smaapass);
    var pass = new POSTPROCESSING.GodRaysPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = false;
    composerTolppa.addPass(pass);
    var bokehPass2 =  new POSTPROCESSING.BokehPass(cameraTolppa);
    bokehPass2.renderToScreen = false;
    composerTolppa.addPass(bokehPass2);
    bokehtolppa = bokehPass2;

    var pass = new POSTPROCESSING.FilmPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = true;
    filmTolppa = pass;
    composerTolppa.addPass(pass);


    composerPalaset = new POSTPROCESSING.EffectComposer(renderer);
    var scenePass2 = new POSTPROCESSING.RenderPass(scenePalaset, cameraPalaset)
    composerPalaset.addPass(scenePass2);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerPalaset.addPass(smaapass);
    var bokehPass2 =  new POSTPROCESSING.BokehPass(cameraPalaset);
    bokehPass2.renderToScreen = false;
    composerPalaset.addPass(bokehPass2);
    bokehrose = bokehPass2;
    var pass = new POSTPROCESSING.FilmPass(scenePalaset,cameraPalaset);
    pass.renderToScreen = true;
    filmPalaset = pass;
    composerPalaset.addPass(pass);


    composerTori = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneTori, cameraTori)
    composerTori.addPass(scenePass);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerTori.addPass(smaapass);
    var bokehPass2 =  new POSTPROCESSING.BokehPass(cameraTori);
    bokehPass2.renderToScreen = false;
    composerTori.addPass(bokehPass2);
    bokehtori = bokehPass2;
    var pass = new POSTPROCESSING.FilmPass(sceneTori,cameraTori);
    pass.renderToScreen = true;
    filmTori = pass;
    composerTori.addPass(pass);


    composerHall = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneHall, cameraHall)
    composerHall.addPass(scenePass);
    var smaapass = new POSTPROCESSING.SMAAPass( window.innerWidth, window.innerHeight );
    smaapass.renderToScreen = false;
    composerHall.addPass(smaapass);

    var bokehPass =  new POSTPROCESSING.BokehPass(cameraHall);
    bokehPass.renderToScreen = false;
    composerHall.addPass(bokehPass);
    bokeh = bokehPass;
    var pass = new POSTPROCESSING.FilmPass(sceneHall,cameraHall);
    pass.renderToScreen = true;
    filmHall = pass;
    composerHall.addPass(pass);

    composerBranch = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneBranch, cameraBranch)
    composerBranch.addPass(scenePass);

    var bokehPass =  new POSTPROCESSING.BokehPass(cameraBranch);
    bokehPass.renderToScreen = false;
    composerBranch.addPass(bokehPass);
    bokehbranch = bokehPass;
    var pass = new POSTPROCESSING.FilmPass(sceneBranch,cameraBranch);
    pass.renderToScreen = true;
    filmBranch = pass;
    composerBranch.addPass(pass);

    initParticles();

    document.body.appendChild( renderer.domElement );

    syncDevice = new JSRocket.SyncDevice();
    if (demoMode) {
        syncDevice.setConfig({'rocketXML':'sync2.rocket'});
        syncDevice.init("demo");
    } else {
        //_syncDevice.setConfig({'socketURL':'ws://192.168.0.100:1339'});
        syncDevice.init();
    }
    syncDevice.on('ready', onSyncReady);
    syncDevice.on('update', onSyncUpdate);
    syncDevice.on('play', onPlay);
    syncDevice.on('pause', onPause);

    audioElement = document.getElementById("audio");


}

var preloader = 0;

function preloadScenes() {
    if (preloader == 0) {
        scenePass.camera = cameraTolppa;
        scenePass.scene = sceneTolppa;
        composerTolppa.render(100*preloader);
    } else if (preloader == 1) {  
        scenePass.camera = cameraHall;
        scenePass.scene = sceneHall;
        composerHall.render(100*preloader); 
    } else if (preloader == 2) {  
        scenePass.camera = cameraPalaset;
        scenePass.scene = scenePalaset;
        composerPalaset.render(100*preloader);
    } else if (preloader == 3) {  
        scenePass.camera = cameraTori;
        scenePass.scene = sceneTori;
        composerTori.render(100*preloader);
    } else if (preloader == 4) {  
        renderer.render(bufferScene, cameraBranchEff, bufferTexture);
        renderer.render( sceneBranch, cameraBranch );
    }

    loader.innerHTML += ".";

    preloader++;
    if (preloader < 5) setTimeout(preloadScenes, 100);
    else render();

}




function onAudioReady() {
    audioInited = true;
    setTimeout(preloadScenes, 500);
}

function onSyncReady(){
  //jsRocket is done getting all the info you already have in Rocket, or is done parsing the .rocket file

  //this either adds a track to Rocket, or gets it for you
  current_scene = syncDevice.getTrack('current_scene');
  rocket_meshx = syncDevice.getTrack('mesh_x');
  rocket_meshy = syncDevice.getTrack('mesh_y');
  rocket_meshz = syncDevice.getTrack('mesh_z');
  rocket_meshr = syncDevice.getTrack('mesh_r');
  rocket_mesha = syncDevice.getTrack('mesh_a');

  rocket_camerax = syncDevice.getTrack('camera_x');
  rocket_cameray = syncDevice.getTrack('camera_y');
  rocket_cameraz = syncDevice.getTrack('camera_z');
  rocket_camerarx = syncDevice.getTrack('camera_rx');
  rocket_camerary = syncDevice.getTrack('camera_ry');
  rocket_camerarz = syncDevice.getTrack('camera_rz');
  rocket_effutime = syncDevice.getTrack('effutime');

  rocket_aperture = syncDevice.getTrack('aperture');
  rocket_dof = syncDevice.getTrack('dof');
  rocket_focus = syncDevice.getTrack('focus');

  rocket_textIndex = syncDevice.getTrack('current_text');

  rocket_light1x = syncDevice.getTrack('light1_x');
  rocket_light1y = syncDevice.getTrack('light1_y');
  rocket_light1z = syncDevice.getTrack('light1_z');
  rocket_light1i = syncDevice.getTrack('light1_int');

  rocket_light2x = syncDevice.getTrack('light2_x');
  rocket_light2y = syncDevice.getTrack('light2_y');
  rocket_light2z = syncDevice.getTrack('light2_z');
  rocket_light2i = syncDevice.getTrack('light2_int');

  rocket_light3x = syncDevice.getTrack('light3_x');
  rocket_light3y = syncDevice.getTrack('light3_y');
  rocket_light3z = syncDevice.getTrack('light3_z');
  rocket_light3i = syncDevice.getTrack('light3_int');

  rocket_light4x = syncDevice.getTrack('light4_x');
  rocket_light4y = syncDevice.getTrack('light4_y');
  rocket_light4z = syncDevice.getTrack('light4_z');
  rocket_light4i = syncDevice.getTrack('light4_int');

  rocket_light5x = syncDevice.getTrack('light5_x');
  rocket_light5y = syncDevice.getTrack('light5_y');
  rocket_light5z = syncDevice.getTrack('light5_z');
  rocket_light5i = syncDevice.getTrack('light5_int');

  rocket_eye = syncDevice.getTrack('eyes');

  syncReady = true;
}

function onSyncUpdate(newRow){
  //row is only given if you navigate, or change a value on the row in Rocket
  //on interpolation change (hit [i]) no row value is sent, as the current there is the upper row of your block
  if(!isNaN(row)){
    row = newRow;
  }
  audioElement.currentTime = row/ROW_RATE;
  render();
}

function onPlay(){
  //you could also set tune.currentTime here
  console.log("[onPlay] time in seconds", row / ROW_RATE);
  audioElement.loop = false;
  audioElement.play();
  render();
}

function onPause(){
  //pause your tune
  console.log("[onPause] time in seconds", row / ROW_RATE);
  audioElement.pause();
}

var sceneTime = 0;
var sceneStartTime = 0;
var prevTime = 0;
var delta = 0;
var meshcopy = null;
var cposx = new Array(100);
var cposy = new Array(100);
var cposz = new Array(100);
var demoTime = 0;
var textIndex = -1;

function clamp(num, min, max) {
  return num <= min ? min : num >= max ? max : num;
}

function easeInOut(t) {
  return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1
}

function doLights(currentRow, scene) {
    var light = 0;
    scene.traverse( function ( child ) {
        if ( child instanceof THREE.HemisphereLight ||
             child instanceof THREE.PointLight ||
             child instanceof THREE.SpotLight) {

            if (light == 0) {
                child.position.x = rocket_light1x.getValue(currentRow);
                child.position.y = rocket_light1y.getValue(currentRow);
                child.position.z = rocket_light1z.getValue(currentRow);
                child.intensity  = rocket_light1i.getValue(currentRow); 
            } else if (light == 1) {
                child.position.x = rocket_light2x.getValue(currentRow);
                child.position.y = rocket_light2y.getValue(currentRow);
                child.position.z = rocket_light2z.getValue(currentRow);
                child.intensity  = rocket_light2i.getValue(currentRow);                 
            } else if (light == 2) {
                child.position.x = rocket_light3x.getValue(currentRow);
                child.position.y = rocket_light3y.getValue(currentRow);
                child.position.z = rocket_light3z.getValue(currentRow);
                child.intensity  = rocket_light3i.getValue(currentRow);                 
            } else if (light == 3) {
                child.position.x = rocket_light4x.getValue(currentRow);
                child.position.y = rocket_light4y.getValue(currentRow);
                child.position.z = rocket_light4z.getValue(currentRow);
                child.intensity  = rocket_light4i.getValue(currentRow);                 
            } else if (light == 4) {
                child.position.x = rocket_light5x.getValue(currentRow);
                child.position.y = rocket_light5y.getValue(currentRow);
                child.position.z = rocket_light5z.getValue(currentRow);
                child.intensity  = rocket_light5i.getValue(currentRow);                 
            }
            light++;
        }
    });

}

function render() {
    if (syncReady === false) return;

    var currentRow = audioElement.currentTime * ROW_RATE;
            if(audioElement.paused === false) {
                //otherwise we may jump into a point in the audio where there's
                //no timeframe, resulting in Rocket setting row 2 and we report
                //row 1 back - thus Rocket spasming out
                // this informs Rocket where we are
                syncDevice.update(currentRow);
            }

    millis = (currentRow/ROW_RATE)-sceneStartTime;

    delta = millis-prevTime;
    sceneTime+=delta;

    sceneIndex = current_scene.getValue(currentRow);

    demoTime += delta;

    if (prevSceneIndex != sceneIndex) {
        prevSceneIndex = sceneIndex;
        sceneStartTime = (currentRow/ROW_RATE);
    }

    var newTextIndex = rocket_textIndex.getValue(currentRow);

    if (newTextIndex != textIndex) animateText("text"+textIndex);

    textIndex = newTextIndex;

    if (sceneIndex == 0) {
        tuniform.iTime.value = rocket_effutime.getValue(currentRow);

        cameraPalaset.position.x = rocket_camerax.getValue(currentRow);
        cameraPalaset.position.y = rocket_cameray.getValue(currentRow);
        cameraPalaset.position.z = rocket_cameraz.getValue(currentRow);
        cameraPalaset.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraPalaset.rotation.y = rocket_camerary.getValue(currentRow);
        cameraPalaset.rotation.z = rocket_camerarz.getValue(currentRow);

        doLights(currentRow,scenePalaset);

        if (roseclone) { 
            var i = 0;

        var breaktime = rocket_effutime.getValue(currentRow);

            roseclone.material.displacementMap = tgTexture;
            roseclone.material.displacementScale = Math.max(0.0,1.0-breaktime*0.15);
            roseclone.material.displacementBias = 0.0;
            roseclone.material.displacementMap.needsUpdate = true;
            roseclone.material.envMap = tgTexture;
            roseclone.receiveShadow = true;
            roseclone.castShadow = true;
            roseclone.material.emissiveColor = new THREE.Color( 0xff0000 );;

            roseclone.material.needsUpdate = true;
            roseclone.rotation.z += delta*0.5;
        }
        bokehrose.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokehrose.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokehrose.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);
        filmPalaset.material.uniforms.vignetteDarkness.value = rocket_eye.getValue(currentRow);

/*
        sphereMesh.position.z = 1.5;
        sphereMesh.position.y = 1.2;
        sphereMesh.position.x = -0.05;
*/
        composerPalaset.render(clock.getDelta());
//      renderer.render( scenePalaset, cameraPalaset );
    } else if (sceneIndex == 1) {
        scenePass.camera = cameraTolppa;
        scenePass.scene = sceneTolppa;

        doLights(currentRow,sceneTolppa);

        var animTime = clamp(sceneTime*0.1,0.0,1.0);
        sphereMesh2.position.x = rocket_meshx.getValue(currentRow);
        sphereMesh2.position.y = rocket_meshy.getValue(currentRow);
        sphereMesh2.position.z = rocket_meshz.getValue(currentRow);
        sphereMesh2.rotation.y = rocket_meshr.getValue(currentRow);
        tuniform.iTime.value = millis;
        tuniform.iAlpha.value = rocket_mesha.getValue(currentRow);
        materialTolppa.opacity = THREE.Math.lerp(0.0,0.1,easeInOut(animTime));

        cameraTolppa.lookAt(new THREE.Vector3(0.0,0.05,0.5));

        cameraTolppa.position.x = noise.perlin3(millis,millis,millis)*0.004;
        cameraTolppa.position.y = noise.perlin3(millis,millis,millis)*0.002;
        cameraTolppa.position.z = noise.perlin3(millis,millis,millis)*0.003;
        bokehtolppa.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokehtolppa.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokehtolppa.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);
        filmTolppa.material.uniforms.vignetteDarkness.value = rocket_eye.getValue(currentRow);

        composerTolppa.render(clock.getDelta());
        //renderer.render( sceneTolppa, cameraTolppa );

    } else if (sceneIndex == 2 || sceneIndex == 5) {

    particleGroup1.tick( clock.getDelta() );

//        cameraTori.setTarget( 'poliistarget' );
//        cameraTori.update();
        scenePass.camera = cameraTori;
        scenePass.scene = sceneTori;
//        poliis.rotation.z = Math.abs(Math.cos(millis*0.1)*2.5)+Math.sin(millis*0.1)*0.1;
        var animTime = clamp(sceneTime*0.1,0.0,1.0);
        sphereMesh3.position.x = rocket_meshx.getValue(currentRow);
        sphereMesh3.position.y = rocket_meshy.getValue(currentRow);
        sphereMesh3.position.z = rocket_meshz.getValue(currentRow);
        sphereMesh3.rotation.y = rocket_meshr.getValue(currentRow);
        tuniform.iTime.value = millis;
        tuniform.iAlpha.value = rocket_mesha.getValue(currentRow);
        materialTolppa.opacity = THREE.Math.lerp(0.0,0.1,easeInOut(animTime));

        if (rose) rose.rotation.z += delta*0.5;


        cameraTori.position.x = rocket_camerax.getValue(currentRow);
        cameraTori.position.y = rocket_cameray.getValue(currentRow);
        cameraTori.position.z = rocket_cameraz.getValue(currentRow);

        cameraTori.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraTori.rotation.y = rocket_camerary.getValue(currentRow);
        cameraTori.rotation.z = rocket_camerarz.getValue(currentRow);
//        cameraTori.position.x=-2.5;
//        cameraTori.position.y=-20.5+millis*1.2;
//        cameraTori.position.z=-2.+Math.cos(millis)*3.;
//        cameraTori.rotation.x=Math.cos(millis*0.5)*0.5;

        doLights(currentRow,sceneTori);
/*
        spotLight_tori1.intensity = 1.0;
        spotLight_tori2.intensity = 1.0;
        spotLight_tori1.position = cameraTori.position;
        spotLight_tori2.position = cameraTori.position;
*/
        bokehtori.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokehtori.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokehtori.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);
        filmTori.material.uniforms.vignetteDarkness.value = rocket_eye.getValue(currentRow);

        composerTori.render(clock.getDelta());

    } else if (sceneIndex == 3) {
        scenePass.camera = cameraHall;
        scenePass.scene = sceneHall;
        cameraHall.position.x = rocket_camerax.getValue(currentRow);
        cameraHall.position.y = rocket_cameray.getValue(currentRow);
        cameraHall.position.z = rocket_cameraz.getValue(currentRow);
        cameraHall.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraHall.rotation.y = rocket_camerary.getValue(currentRow);
        cameraHall.rotation.z = rocket_camerarz.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokeh.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);

        tuniform.iTime.value = rocket_effutime.getValue(currentRow);
        tuniform.iAlpha.value = rocket_mesha.getValue(currentRow);
        materialPink.opacity = 1.0;

        renderer.render(bufferScene2, cameraPinkEff, bufferTexture2);

/*
        spotLight_hall1.position.z = Math.abs(Math.cos(millis*0.2)*2.);
        spotLight_hall1.position.x = 5.-Math.abs(Math.sin(millis*0.5)*5.);
*/
        doLights(currentRow,sceneHall);
        filmHall.material.uniforms.vignetteDarkness.value = rocket_eye.getValue(currentRow);

        composerHall.render(clock.getDelta());
    } else if (sceneIndex == 4) {
        scenePass.camera = cameraBranch;
        scenePass.scene = sceneBranch;

        bokehbranch.bokehMaterial.uniforms.focus.value = rocket_focus.getValue(currentRow);
        bokehbranch.bokehMaterial.uniforms.dof.value = rocket_dof.getValue(currentRow);
        bokehbranch.bokehMaterial.uniforms.aperture.value = rocket_aperture.getValue(currentRow);

        cameraBranch.position.x = rocket_camerax.getValue(currentRow);
        cameraBranch.position.y = rocket_cameray.getValue(currentRow);
        cameraBranch.position.z = rocket_cameraz.getValue(currentRow);

        cameraBranch.rotation.x = rocket_camerarx.getValue(currentRow);
        cameraBranch.rotation.y = rocket_camerary.getValue(currentRow);
        cameraBranch.rotation.z = rocket_camerarz.getValue(currentRow);
        tuniform.iTime.value = rocket_effutime.getValue(currentRow);
        tuniform.iResolution.value = new THREE.Vector2(window.innerWidth*0.5,window.innerHeight*0.5);
        tuniform.iMouse.value = new THREE.Vector2(rocket_meshx.getValue(currentRow),rocket_meshy.getValue(currentRow));
        filmBranch.material.uniforms.vignetteDarkness.value = rocket_eye.getValue(currentRow);

        renderer.render(bufferScene, cameraBranchEff, bufferTexture);
        composerBranch.render(clock.getDelta());
//        renderer.render( sceneBranch, cameraBranch );
    }

    prevTime = millis;

    if(demoMode && audioElement.paused) {
        loader.innerHTML = "";
        document.getElementById("blocker").style.display = "none";
        audioElement.play();
    }

    if (!demoMode) {
        loader.innerHTML = "";
        document.getElementById("blocker").style.display = "none";
    }

    if (audioElement.paused === false) window.requestAnimationFrame(render);

}


function animateText(name) {
    var $el = $("." + name + ":first"), text = $.trim($el.text()),
        words = text.split(" "), html = "";

    var topUpper = 33;
    var topStep = 18; // font-size: 48px;
    var fadeFloat = 3;
    var textY = topUpper;
    var leftStep = 32;
    var textX = 20 + leftStep;

    

    for (var i = 0; i < words.length; i++) {
        console.log('word: ' + words[i]);
        var $textEffectStyle = '';
        if(words[i] == 'Quadtrip' || words[i] == 'Isildur^Samar'|| words[i] == 'branch' || words[i] == 'visy' || words[i] == 'zov') {
          $textEffectStyle = 'background: #343F61;';
        } else if(words[i] == 'Vortex&nbsp;2017') {
          $textEffectStyle = 'text-decoration: underline;';
        }

        html += '<span style="' + $textEffectStyle + '">' + words[i] + ((i+1) === words.length ? '' : ' ') + '</span>';
    };

    window.leftpres = 0;


    $el.html(html).children().hide().each(function(i){
      console.log('current textpart: ' + $(this).html() + ', top value: ' + textY);

        window.leftpres = 12 + ((i*25) % 75);

        if (window.preve) { 
            window.preve.animate({ opacity: 0, top: textY - fadeFloat + '%'}, 1000);
        }

        var value = 0x9F + Math.random() * 0x5F | 0;
        var grayscale = (value << 16) | (value << 8) | value;
        //var color = '#' + grayscale.toString(16);

        if ($(this).html().indexOf('#restarty') > -1) {
          console.log('linebreik');
          $(this).html($(this).html().replace('#restarty', ''));
          textY = topUpper;
        }

        if ($(this).html().indexOf('#leftpush') > -1) {
          console.log('leftyy');
          $(this).html($(this).html().replace('#leftpush', ''));
          textX += leftStep;
        }

        if ($(this).html().indexOf('#leftzero') > -1) {
          console.log('lefty zero');
          $(this).html($(this).html().replace('#leftzero', ''));
          textX = leftStep;
        }

        if ($(this).html().indexOf('#linebr') > -1) {
          console.log('linebreik');
          $(this).html($(this).html().replace('#linebr', ''));
          textY += topStep;
        }

        if ($(this).html().indexOf('#pause') > -1) {
          console.log('pausella');
          $(this).html($(this).html().replace('#pause', ''));
        } else { 
        console.log('eipause');
            $(this).delay((i*900)).fadeIn(800); 
            $(this).css('left', leftpres + "%"); 
            $(this).css('margin-left', leftpres + "px"); 
             $(this).css('top', textY + '%');
        }
        window.preve = $(this);
        window.prevleftpres = window.leftpres;
    });
    var $el = $("."+name);
    $el.animate({opacity: 0.8});
    $el.find("span").promise().done(function(){
        if (window.preve) { 
            window.preve.animate({ opacity: 0, top: textY - fadeFloat + '%' }, 800);
        }
    });    
}

</script>
</head>

<body>
<script>
    window.addEventListener('load', function() {
        init();
        console.log("demo start");
    }, false);

</script>
<div id = "blocker" style = "width:100%; height: 100%; position:fixed; background-color: black;z-index: 5;"></div>

<div id = "loader" style = "position:fixed;left:0%;top:85%; color: white; font-size:48px; z-index: 6">loading data, please wait...</div>
<audio id="audio" style = "display:none" preload="auto" loop=false>
    <source src="plz_u.ogg" id="oggSource" type="audio/ogg" />
    <source src="plz_u.mp3" id="mp3Source" type="audio/mpeg" />
</audio>
<p class = "text1">#leftzero #restarty does&nbsp;it&nbsp;matter #linebr #linebr #leftpush that much #pause anyway?</p>
<p class = "text2">#restarty #leftpush #leftpush Quadtrip presents #pause #linebr #leftzero Demon&nbsp;Nimi #linebr for Vortex&nbsp;2017</p>
<p class = "text3">#leftzero #restarty the&nbsp;whole&nbsp;world #pause #linebr ripping out #pause at&nbsp;the&nbsp;seams #pause #pause #pause #linebr #linebr collapsing&nbsp;inward on itself</p>
<p class = "text4">#leftzero #restarty pieces flying off #pause #pause #pause into the depths like shrapnel</p>
<p class = "text5">#leftzero #restarty planting broken seeds #pause #pause #pause #linebr growing mucous memberanes and oily leaves</p>
<p class = "text6">#leftzero #restarty ball&nbsp;and&nbsp;lines&nbsp;shader branch #linebr #linebr #linebr other&nbsp;shaders&nbsp;main&nbsp;code design visy #linebr music&nbsp;and&nbsp;sync zov #linebr Quadtrip&nbsp;logo Isildur^Samar</p>

</body>
</html>
