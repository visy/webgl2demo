<html>
<head>
<style type = "text/css">
body {
  margin: 0px;
  overflow: hidden;
}
</style>
<script src = "three.min.js">
</script>
<script id = "vertexShader" type = "glsl">
varying vec2 vUv; 
void main()
{
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id = "fragmentTolppa" type = "glsl">
uniform float iTime;
varying vec2 vUv;

float NEAR_CLIPPING_PLANE=.005;
float FAR_CLIPPING_PLANE=1000.;
int NUMBER_OF_MARCH_STEPS=500;
float EPSILON=.1;
float DISTANCE_BIAS=.3;
float t = 0.;

float sdSphere(vec3 p, float s)
{
    return length(p) - (s);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float fOpUnionRound(float a, float b, float r) {
    vec2 u = max(vec2(r - a,r - b), vec2(0));
    return max(r, min (a, b)) - length(u);
}


float scene(vec3 pos)
{
    vec3 translate = vec3(-0.1, fract(pos.y*clamp(iTime*0.05,0.,1.0)), 0.);

    vec3 opos = pos - translate;

    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.01+cos(pos.x*1.1)*0.1)*0.2)*3.91;
        
    return finalDist;
}

float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = scene( aopos );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}


vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.;
    for(int i = 0 ; i < 500 ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        float result = scene(pos);
        acc+=cos(result*1.)*.05;

        if(result < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result * DISTANCE_BIAS;
        
        
        if(total_distance > FAR_CLIPPING_PLANE)
            discard;
    }
    return vec2(FAR_CLIPPING_PLANE, acc);
}

vec3 nr(vec3 n) {
    return normalize(n);
}

vec3 normal( in vec3 pos )
{
    vec3 eps = vec3(.3,0.,0.)*EPSILON;
    vec3 nor = vec3(
        scene(pos+eps.xyy) - scene(pos-eps.xyy),
        scene(pos+eps.yxy) - scene(pos-eps.yxy),
        scene(pos+eps.yyx) - scene(pos-eps.yyx) );
    return nr(nor);
}



float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1., max(NdotL, NdotV), step(0., s));

  float sigma2 = roughness * roughness;
  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));
  float B = .45 * sigma2 / (sigma2 + .09);

  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;
}

void main() {
    // pixel coordinates
    vec2 uv = -1.0 + 2.0 * vUv;
    
    vec3 direction = nr(vec3(uv, 0.));

    t = iTime*3.;

    float cz = t*5.9;
    

    float FOV = 1.;
        
        vec3 camera_origin = vec3(0., 1., cz);
    vec3 lookAt = vec3(0.,1.,cz+1.);
    
    vec3 forward = nr(lookAt-camera_origin);
    vec3 right = nr(vec3(forward.z, 0., -forward.x ));
    vec3 up = nr(cross(forward,right));

    
    vec3 ro = camera_origin;
    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    float fog = pow(1. / (1. + result.x), .2);
    
    vec3 icecol = vec3(.6,.6,1.0);
    vec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);
    vec3 intersection = ro + rd*result.x;
    
    vec3 nrml = normal(intersection);
    vec3 light_dir = nr(vec3(0.,.0,-1.));
    vec3 ref = reflect( rd, nrml );

    float dom = smoothstep( -.1, .9, ref.y);
    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);

    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3,.3)-result.y*.05;
    
    vec3 light_color = vec3(1.);
    vec3 ambient_color = light_color;
    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;
    if (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(0.0);
    gl_FragColor = vec4(outColor,1.0);
 }
</script>

<script id = "fragmentPalaset" type = "glsl">
uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
varying vec2 vUv;
float PI=3.14159;

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898+co.y,78.233+co.x))) * 5.*iTime*0.01+43758.5453);
}

float pix(vec2 uv){
    return step(0.5+uv.y*0.01+(cos(uv.x*0.01+10.*iTime*0.5)*0.001),rand(floor(uv)));    
}

float hm(vec2 uv){
    uv*=2.0;
    vec2 nuv = (fract(uv)-0.5)*4.;
    vec2 pos = sign(nuv)*0.4-distance(nuv.yx,uv.yx)*(cos(10.*iTime+nuv.x*nuv.y)*0.04);
    
    float d = length(nuv);
    
    float v = pix(uv);
    
    if(d>1.){
    
    vec2 p1=vec2(pos.x,0.),
         p2=vec2(0.,pos.y);
    
    float v1 = pix(uv+p1),
          v2 = pix(uv+p2);
    
        if(v1==v2){
            if(v==pix(uv+pos) && v!=v1) v=0.;
            else v=v1;
        }
    }   
    
    return mix(pix(uv),v,smoothstep(d,1.0,1.1));
}

vec3 shade(vec2 uv){
    uv*=5.;
    return vec3(hm(uv));
}

void main()
{
    vec2 uv = -1.0 + 2.0 * vUv*3.;
    if (uv.x < 0.0) uv.x = 0.0-uv.x;
    if (uv.y < 0.0) uv.y = 0.0-uv.y;
    
    vec3 color = shade(uv);
    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) discard;
    color.rgb*=texture2D(iChannel1,uv).rgb;
    color.rgb-=texture2D(iChannel0,uv+iTime*0.2).rgb*0.5;
    gl_FragColor = vec4(color*vec3(1.1,1.3,0.4),0.5);
}

</script>

<script src = "orbit.js"></script>
<script src = "quad.js"></script>

<script>

var camera;
var cameraPalaset, cameraTolppa, scenePalaset, sceneTollpa, renderer;
var geometry, material, sphereMesh;
var tuniform, clock, audioElement;
var millis, controls, sceneIndex, prevSceneIndex;
var screenQuad;

// demo init

function init() {

	cameraPalaset = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 0.01, 10 );
    cameraTolppa = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        cameraPalaset.position.z = 0.2;

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize(){
	    cameraPalaset.aspect = window.innerWidth / window.innerHeight;
	    cameraPalaset.updateProjectionMatrix();
        cameraTolppa.aspect = window.innerWidth / window.innerHeight;
        cameraTolppa.updateProjectionMatrix();

        screenQuad.setScreenSize( window.innerWidth*0.1, window.innerHeight*0.1 );
	    renderer.setSize( window.innerWidth, window.innerHeight );
	}

    prevSceneIndex = -1;
    sceneIndex = 1;

	clock = new THREE.Clock;
	scenePalaset = new THREE.Scene();
    sceneTolppa = new THREE.Scene();
    controls = new THREE.OrbitControls( cameraPalaset );

    controls.autoRotate = true;

	var loader = new THREE.TextureLoader();
	
	tuniform = {
        iTime: 		{ type: 'f', value: 0.1 },
        iChannel0:  { type: 't', value: loader.load( 'tex1.jpg') },
        iChannel1:  { type: 't', value: loader.load( 'tex2.jpg' ) },
    };

	tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
	tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

	var materialPala = new THREE.ShaderMaterial({
        uniforms: tuniform,
		vertexShader: document.getElementById( 'vertexShader' ).textContent,
		fragmentShader: document.getElementById( 'fragmentPalaset' ).textContent,
        side:THREE.DoubleSide,
        transparent: true,
	});


    var materialTolppa = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentTolppa' ).textContent,
    });

	geometry = new THREE.SphereGeometry( 0.2, 16, 16 );
	sphereMesh = new THREE.Mesh( geometry, materialPala );
	scenePalaset.add( sphereMesh );

    var path = "horn/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube = new THREE.CubeTextureLoader().load( urls );
    cube.format = THREE.RGBFormat;

    scenePalaset.background = cube;
    controls.center = sphereMesh.center;

    screenQuad = new ScreenQuad({
        width: 0.01,
        height: 0.01,
    });

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor( 0x000000, 1);

    screenQuad.setScreenSize( renderer.getSize().width*0.1 , renderer.getSize().height*0.1 );
    screenQuad.material = materialTolppa;

    sceneTolppa.add(screenQuad);

	document.body.appendChild( renderer.domElement );

	audioElement = document.getElementById("audio");
	console.log(audioElement);
	audioElement.play();
}

var sceneTime = 0;
var prevTime = 0;
var delta = 0;

function animate() {

	requestAnimationFrame( animate );
    millis = audioElement.currentTime;
	tuniform.iTime.value = millis;

    delta = millis-prevTime;
    sceneTime+=delta;

    if (sceneTime > 15.) {
        sceneTime = 0;
        
        if (sceneIndex == 1) sceneIndex = 0;
        else sceneIndex = 1;   
    }


    if (prevSceneIndex != sceneIndex) {
        prevSceneIndex = sceneIndex;
    }

    if (sceneIndex == 0) {
        controls.update();

    	renderer.render( scenePalaset, cameraPalaset );
    } else if (sceneIndex == 1) {
        cameraTolppa.position.z = 0.5;
        renderer.render( sceneTolppa, cameraTolppa );

    }

    prevTime = millis;

}
</script>
</head>

<body>
<script>
	window.addEventListener('load', function() {
		init();
		console.log("demo start");
		animate();
	}, false);

</script>
<audio id="audio" style = "display:none" preload="auto">
	<source src="pzlu3.ogg" id="oggSource" type="audio/ogg" />
	<source src="pzlu3.mp3" id="mp3Source" type="audio/mpeg" />
</audio>
</body>
</html>
