<html>
<head>
<style type = "text/css">
body {
  margin: 0px;
  overflow: hidden;
}
</style>
<script src = "three.min.js">
</script>
<script id = "vertexShader" type = "glsl">
varying vec2 vUv; 
void main()
{
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id = "fragmentTolppa" type = "glsl">
uniform float iTime;
varying vec2 vUv;

#define NEAR_CLIPPING_PLANE 0.005
#define FAR_CLIPPING_PLANE 1000.0
#define NUMBER_OF_MARCH_STEPS 400
#define EPSILON 0.1
#define DISTANCE_BIAS 0.2

float sdSphere(vec3 p, float s)
{
    return length(p) - (s);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}


vec2 scene(vec3 pos)
{
    vec3 translate = vec3(-0.1, fract(pos.y), 0.);

    vec3 opos = pos - translate;

    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.01+cos(pos.x*1.1)*0.1)*0.2)*3.91;
        
    return vec2(finalDist, 2.0);
}

float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = scene( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}


vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.0;
    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        vec2 result = scene(pos);
        acc+=cos(result.x*1.)*0.05;

        if(result.x < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result.x * DISTANCE_BIAS;
        
        
        if(total_distance > FAR_CLIPPING_PLANE)
            break;
    }
    return vec2(FAR_CLIPPING_PLANE, acc);
}

vec3 normal(vec3 ray_hit_position, float smoothness)
{   
    vec3 n;
    vec2 dn = vec2(smoothness, 0.0);
    n.x = scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;
    n.y = scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;
    n.z = scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;
    return normalize(n);
}

void main()
{
    
    vec3 tot = vec3(0.0);

    // pixel coordinates
        vec2 uv = -1.0 + 2.0 * vUv;


    vec3 direction = normalize(vec3(uv, 0.0));
    float cx = 0.0;
    float cy = 0.*0.01+cos(iTime*0.5)*1.;
    float cz = 0.*0.01+iTime*15.;
    vec3 camera_origin = vec3(cx, cy, cz);
    vec3 lookAt = vec3(cx,cy,cz+1.);
    
    vec3 forward = normalize(lookAt-camera_origin); // Forward vector.
    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); // Right vector... or is it left? Either way, so long as the correct-facing up-vector is produced.
    vec3 up = normalize(cross(forward,right)); // Cross product the two vectors above to get the up vector.

    float FOV = 1.55;

    vec3 ro = camera_origin;
    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    float fog = pow(1.0 / (1.0 + result.x), 0.3);
    
    vec3 materialColor = vec3(0.0, 0.0, 0.0);
        materialColor = vec3(1.0-result.x*0.01*0.5,0.9-cos(result.x*0.1)*0.5,1.0*0.5);
    vec3 intersection = ro + rd * result.x;
    
    vec3 nrml = normal(intersection, 0.1);
    float occ = calcAO( intersection, nrml );
    vec3 light_dir = normalize(vec3(0.0, 0.0, -1.0));
    vec3 ref = reflect( rd, nrml );
    float dom = smoothstep( -0.1, 0.1, ref.y );
    float spe = pow(clamp( dot( ref, light_dir ), 0.0, 1.0 ),32.0);

    float diffuse = dot(light_dir, nrml)-result.y*0.3;

    diffuse = diffuse * 0.5 + 0.5;
        
    vec3 light_color = vec3(1.0, 1.0, 1.0);
    vec3 ambient_color = vec3(1.0,1.0, 1.0);
    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
    vec3 outColor = diffuseLit*occ*fog+dom*0.1+spe*0.3;
    if (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(0.0);
    gl_FragColor = vec4(outColor, 1.0);

}

</script>

<script id = "fragmentPalaset" type = "glsl">
uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
varying vec2 vUv;
float PI=3.14159;

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898+co.y,78.233+co.x))) * 5.*iTime*0.01+43758.5453);
}

float pix(vec2 uv){
    return step(0.5+uv.y*0.01+(cos(uv.x*0.01+10.*iTime*0.5)*0.001),rand(floor(uv)));    
}

float hm(vec2 uv){
    uv*=2.0;
    vec2 nuv = (fract(uv)-0.5)*4.;
    vec2 pos = sign(nuv)*0.4-distance(nuv.yx,uv.yx)*(cos(10.*iTime+nuv.x*nuv.y)*0.04);
    
    float d = length(nuv);
    
    float v = pix(uv);
    
    if(d>1.){
    
    vec2 p1=vec2(pos.x,0.),
         p2=vec2(0.,pos.y);
    
    float v1 = pix(uv+p1),
          v2 = pix(uv+p2);
    
        if(v1==v2){
            if(v==pix(uv+pos) && v!=v1) v=0.;
            else v=v1;
        }
    }   
    
    return mix(pix(uv),v,smoothstep(d,1.0,1.1));
}

vec3 shade(vec2 uv){
    uv*=5.;
    return vec3(hm(uv));
}

void main()
{
    vec2 uv = -1.0 + 2.0 * vUv*3.;
    if (uv.x < 0.0) uv.x = 0.0-uv.x;
    if (uv.y < 0.0) uv.y = 0.0-uv.y;
    
    vec3 color = shade(uv);
    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) discard;
    color.rgb*=texture2D(iChannel1,uv).rgb;
    color.rgb-=texture2D(iChannel0,uv+iTime*0.2).rgb*0.5;
    gl_FragColor = vec4(color*vec3(1.1,1.3,0.4),0.5);
}

</script>

<script src = "orbit.js"></script>
<script src = "quad.js"></script>

<script>

var camera;
var cameraPalaset, cameraTolppa, scenePalaset, sceneTollpa, renderer;
var geometry, material, sphereMesh;
var tuniform, clock, audioElement;
var millis, controls, sceneIndex, prevSceneIndex;
var screenQuad;

// demo init

function init() {

	cameraPalaset = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 0.01, 10 );
    cameraTolppa = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        cameraPalaset.position.z = 0.2;

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize(){
	    cameraPalaset.aspect = window.innerWidth / window.innerHeight;
	    cameraPalaset.updateProjectionMatrix();
        cameraTolppa.aspect = window.innerWidth / window.innerHeight;
        cameraTolppa.updateProjectionMatrix();

        screenQuad.setScreenSize( window.innerWidth*0.1, window.innerHeight*0.1 );
	    renderer.setSize( window.innerWidth, window.innerHeight );
	}

    prevSceneIndex = -1;
    sceneIndex = 0;

	clock = new THREE.Clock;
	scenePalaset = new THREE.Scene();
    sceneTolppa = new THREE.Scene();
    controls = new THREE.OrbitControls( cameraPalaset );

    controls.autoRotate = true;

	var loader = new THREE.TextureLoader();
	
	tuniform = {
        iTime: 		{ type: 'f', value: 0.1 },
        iChannel0:  { type: 't', value: loader.load( 'tex1.jpg') },
        iChannel1:  { type: 't', value: loader.load( 'tex2.jpg' ) },
    };

	tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
	tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

	var materialPala = new THREE.ShaderMaterial({
        uniforms: tuniform,
		vertexShader: document.getElementById( 'vertexShader' ).textContent,
		fragmentShader: document.getElementById( 'fragmentPalaset' ).textContent,
        side:THREE.DoubleSide,
        transparent: true,
	});


    var materialTolppa = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentTolppa' ).textContent,
    });

	geometry = new THREE.SphereGeometry( 0.2, 16, 16 );
	sphereMesh = new THREE.Mesh( geometry, materialPala );
	scenePalaset.add( sphereMesh );

    var path = "horn/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube = new THREE.CubeTextureLoader().load( urls );
    cube.format = THREE.RGBFormat;

    scenePalaset.background = cube;
    controls.center = sphereMesh.center;

    screenQuad = new ScreenQuad({
        width: 0.01,
        height: 0.01,
    });

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor( 0xaaffff, 1);

    screenQuad.setScreenSize( renderer.getSize().width*0.1 , renderer.getSize().height*0.1 );
    screenQuad.material = materialTolppa;

    sceneTolppa.add(screenQuad);

	document.body.appendChild( renderer.domElement );

	audioElement = document.getElementById("audio");
	console.log(audioElement);
	audioElement.play();
}

var sceneTime = 0;
var prevTime = 0;
var delta = 0;

function animate() {

	requestAnimationFrame( animate );
    millis = audioElement.currentTime;
	tuniform.iTime.value = millis;

    delta = millis-prevTime;
    sceneTime+=delta;

    if (sceneTime > 15.) {
        sceneTime = 0;
        
        if (sceneIndex == 1) sceneIndex = 0;
        else sceneIndex = 1;   
    }


    if (prevSceneIndex != sceneIndex) {
        prevSceneIndex = sceneIndex;
    }

    if (sceneIndex == 0) {
        controls.update();

    	renderer.render( scenePalaset, cameraPalaset );
    } else if (sceneIndex == 1) {
        cameraTolppa.position.z = 0.5;
        renderer.render( sceneTolppa, cameraTolppa );

    }

    prevTime = millis;

}
</script>
</head>

<body>
<script>
	window.addEventListener('load', function() {
		init();
		console.log("demo start");
		animate();
	}, false);

</script>
<audio id="audio" style = "display:none" preload="auto">
	<source src="pzlu3.ogg" id="oggSource" type="audio/ogg" />
	<source src="pzlu3.mp3" id="mp3Source" type="audio/mpeg" />
</audio>
</body>
</html>
