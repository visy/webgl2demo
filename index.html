<html>
<head>
<style type = "text/css">
body {
  margin: 0px;
  overflow: hidden;
}
</style>
<script src = "three.min.js"></script>
<script src = "postprocessing.js"></script>
<script src = "jsRocket.js"></script>
<script src = "syncdata.js"></script>
<script src = "synctrack.js"></script>
<script src = "syncdeviceplayer.js"></script>
<script src = "syncdeviceclient.js"></script>
<script src = "syncdevice.js"></script>

<script id = "vertexShader" type = "glsl">
varying vec2 vUv; 
void main()
{
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id = "fragmentTolppa" type = "glsl">
uniform float iTime;
uniform float iAlpha;
varying vec2 vUv;

float NEAR_CLIPPING_PLANE=.005;
float FAR_CLIPPING_PLANE=20.;
int NUMBER_OF_MARCH_STEPS=500;
float EPSILON=.1;
float DISTANCE_BIAS=.3;
float t = 0.;

float sdSphere(vec3 p, float s)
{
    return length(p) - (s);
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


float fmod(float a, float b)
{
    if(a<0.0)
    {
        return b - mod(abs(a), b);
    }
    return mod(a, b);
}

const float kHashScale1 = 443.8975;

float hash11(float p) {
  vec3 p3 = fract(vec3(p) * kHashScale1);
  p3 += dot(p3, p3.yzx + 19.19);
  return fract((p3.x + p3.y) * p3.z);
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float fOpUnionRound(float a, float b, float r) {
    vec2 u = max(vec2(r - a,r - b), vec2(0));
    return max(r, min (a, b)) - length(u);
}


float scene(vec3 pos)
{
    vec3 translate1 = vec3(-0.1, fract(pos.y*clamp(iTime*0.05,0.,1.0)), 0.);
    vec3 translate2 = vec3(0.0,distance(1.+abs(cos(pos.x*0.1+cos(iTime*0.1+pos.z+pos.x)*0.5)*10.),pos.y-8.+cos(pos.z)),cos(pos.x+iTime));

    vec3 translate = translate2;

    vec3 opos = pos - translate;

    float finalDist = sdSphere(cos(opos*0.2),1.1+cos(pos.z*0.001+cos(pos.x*1.1)*0.1)*0.2)*3.91;

    return finalDist;
}

vec2 raymarch(vec3 position, vec3 direction)
{
    float total_distance = NEAR_CLIPPING_PLANE;
    float acc = 0.;
    for(int i = 0 ; i < 500 ; ++i)
    {
        vec3 pos = position + direction * total_distance;
        float result = scene(pos);
        acc+=result*0.2;

        if(result < EPSILON)
        {
            return vec2(total_distance, acc);
        }
        
        total_distance += result * DISTANCE_BIAS;
                
        if(total_distance > FAR_CLIPPING_PLANE) return vec2(0.0,-1.0);
    }
    return vec2(0.0,-1.0);
}

vec3 nr(vec3 n) {
    return normalize(n);
}

vec3 normal( in vec3 pos )
{
    vec3 eps = vec3(.3,0.,0.)*EPSILON;
    vec3 nor = vec3(
        scene(pos+eps.xyy) - scene(pos-eps.xyy),
        scene(pos+eps.yxy) - scene(pos-eps.yxy),
        scene(pos+eps.yyx) - scene(pos-eps.yyx) );
    return nr(nor);
}



float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1., max(NdotL, NdotV), step(0., s));

  float sigma2 = roughness * roughness;
  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));
  float B = .45 * sigma2 / (sigma2 + .09);

  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;
}

void main() {
    // pixel coordinates
    vec2 uv = -1.0 + 2.0 * vUv;
    
    vec3 direction = nr(vec3(uv, 0.));

    t = iTime*0.5;

    float cz = t*5.9;
    

    float FOV = 10.0;
        
        vec3 camera_origin = vec3(0., 1., cz);
    vec3 lookAt = vec3(0.0,2.,cz+1.);
    
    vec3 forward = nr(lookAt-camera_origin);
    vec3 right = nr(vec3(forward.z, 0., -forward.x ));
    vec3 up = nr(cross(forward,right));

    
    vec3 ro = camera_origin;
    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);

    vec2 result = raymarch(ro, rd);
            
    if (result.y == -1.0) gl_FragColor = vec4(0.0,0.0,0.0,0.0);
    else {
        float fog = pow(1. / (1. + result.x), .2);
        
        vec3 materialColor = vec3(1.3-result.x*.01*.5,.9,1.*.5)*0.2;
        vec3 intersection = ro + rd*result.x;
        
        vec3 nrml = normal(intersection);
        vec3 light_dir = nr(vec3(0.,.0,-1.));
        vec3 ref = reflect( rd, nrml );

        float dom = smoothstep( -.1, .9, ref.y);
        float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);

        float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.0,0.5)-result.y*.05;
        
        vec3 light_color = vec3(1.);
        vec3 ambient_color = light_color;
        vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);
        vec3 outColor = diffuseLit*fog+dom*.2+spe*.5;
        gl_FragColor = vec4(outColor,iAlpha*(1.0-distance(0.5,result.x)*.1));
    }
 }
</script>

<script id = "fragmentPalaset" type = "glsl">
uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
varying vec2 vUv;
float PI=3.14159;

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898+co.y,78.233+co.x))) * 5.*iTime*0.01+43758.5453);
}

float pix(vec2 uv){
    return step(0.5+uv.y*0.01+(cos(uv.x*0.01+10.*iTime*0.5)*0.001),rand(floor(uv)));    
}

float hm(vec2 uv){
    uv*=2.0;
    vec2 nuv = (fract(uv)-0.5)*4.;
    vec2 pos = sign(nuv)*0.4-distance(nuv.yx,uv.yx)*(cos(10.*iTime+nuv.x*nuv.y)*0.04);
    
    float d = length(nuv);
    
    float v = pix(uv);
    
    if(d>1.){
    
    vec2 p1=vec2(pos.x,0.),
         p2=vec2(0.,pos.y);
    
    float v1 = pix(uv+p1),
          v2 = pix(uv+p2);
    
        if(v1==v2){
            if(v==pix(uv+pos) && v!=v1) v=0.;
            else v=v1;
        }
    }   
    
    return mix(pix(uv),v,smoothstep(d,1.0,1.1));
}

vec3 shade(vec2 uv){
    uv*=5.;
    return vec3(hm(uv));
}

void main()
{
    vec2 uv = -1.0 + 2.0 * vUv*3.;
    if (uv.x < 0.0) uv.x = 0.0-uv.x;
    if (uv.y < 0.0) uv.y = 0.0-uv.y;
    
    vec3 color = shade(uv);
    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) discard;
    color.rgb*=texture2D(iChannel1,uv).rgb;
    color.rgb-=texture2D(iChannel0,uv+iTime*0.2).rgb*0.5;
    gl_FragColor = vec4(color*vec3(1.1,1.3,0.4),0.5);
}

</script>

<script src = "orbit.js"></script>
<script src = "quad.js"></script>

<script>

var camera;
var cameraPalaset, cameraTolppa, scenePalaset, sceneTolppa, renderer;
var geometry, material, sphereMesh;
var tuniform, clock, audioElement;
var millis, sceneIndex, prevSceneIndex;
var screenQuad, sphereMesh2, composer, materialTolppa, scenePass;
var syncReady = false;

var demoMode = true;

var syncDevice,
    //Beats per minute of your demo tune
    BPM = 135,
    //The resolution between two beats, four is usually fine,- eight adds a bit more finer control
    ROWS_PER_BEAT = 8,
    //we calculate this now, so we can translate between rows and seconds later on
    ROW_RATE = BPM / 60 * ROWS_PER_BEAT,
    //your variable that needs tuning in Rocket
    scene1_meshx,
    scene1_meshy,
    scene1_meshz,
    scene1_meshr,
    scene1_mesha,
    scene2_camerar,
    scene2_effutime,
    current_scene,
    //the current row we're on
    row = 0;

// demo init

function init() {

	cameraPalaset = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 0.01, 10 );
    cameraTolppa = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        cameraPalaset.position.z = 0.2;

	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize(){
	    cameraPalaset.aspect = window.innerWidth / window.innerHeight;
	    cameraPalaset.updateProjectionMatrix();
        cameraTolppa.aspect = window.innerWidth / window.innerHeight;
        cameraTolppa.updateProjectionMatrix();

        screenQuad.setScreenSize( window.innerWidth*0.1, window.innerHeight*0.1 );
	    renderer.setSize( window.innerWidth, window.innerHeight );
	}

    prevSceneIndex = -1;
    sceneIndex = 1;

	clock = new THREE.Clock;
	scenePalaset = new THREE.Scene();
    sceneTolppa = new THREE.Scene();

	var loader = new THREE.TextureLoader();
	
	tuniform = {
        iTime: 		{ type: 'f', value: 0.1 },
        iAlpha:     { type: 'f', value: 1.0 }, 
        iChannel0:  { type: 't', value: loader.load( 'tex1.jpg') },
        iChannel1:  { type: 't', value: loader.load( 'tex2.jpg' ) },
    };

	tuniform.iChannel0.value.wrapS = tuniform.iChannel0.value.wrapT = THREE.RepeatWrapping;
	tuniform.iChannel1.value.wrapS = tuniform.iChannel1.value.wrapT = THREE.RepeatWrapping;

	var materialPala = new THREE.ShaderMaterial({
        uniforms: tuniform,
		vertexShader: document.getElementById( 'vertexShader' ).textContent,
		fragmentShader: document.getElementById( 'fragmentPalaset' ).textContent,
        side:THREE.DoubleSide,
        transparent: true,
	});


    materialTolppa = new THREE.ShaderMaterial({
        uniforms: tuniform,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentTolppa' ).textContent,
        transparent: true,
        side:THREE.DoubleSide,
    });

	geometry = new THREE.SphereGeometry( 0.2, 16, 16 );
	sphereMesh = new THREE.Mesh( geometry, materialPala );
	scenePalaset.add( sphereMesh );

    var path = "bud/";
    var format = '.jpg';
    var urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
    ];
    var cube = new THREE.CubeTextureLoader().load( urls );
    cube.format = THREE.RGBFormat;


    sceneTolppa.background = cube;
    scenePalaset.background = cube;

    screenQuad = new ScreenQuad({
        width: 1.,
        height: 1.,
    });

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor( 0x000000, 1);

    screenQuad.setScreenSize( renderer.getSize().width , renderer.getSize().height );
    screenQuad.material = materialTolppa;

    sphereMesh2 = new THREE.Mesh( geometry, materialTolppa );

    sceneTolppa.add(sphereMesh2);

    composer = new POSTPROCESSING.EffectComposer(renderer);
    scenePass = new POSTPROCESSING.RenderPass(sceneTolppa, cameraTolppa)
    composer.addPass(scenePass);
    var pass = new POSTPROCESSING.GodRaysPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = false;
    composer.addPass(pass);
    var pass = new POSTPROCESSING.FilmPass(sceneTolppa,cameraTolppa,sphereMesh2);
    pass.renderToScreen = true;
    composer.addPass(pass);


	document.body.appendChild( renderer.domElement );

    syncDevice = new JSRocket.SyncDevice();
    if (demoMode) {
        syncDevice.setConfig({'rocketXML':'sync.rocket'});
        syncDevice.init("demo");
    } else {
        //_syncDevice.setConfig({'socketURL':'ws://192.168.0.100:1339'});
        syncDevice.init();
    }
    syncDevice.on('ready', onSyncReady);
    syncDevice.on('update', onSyncUpdate);
    syncDevice.on('play', onPlay);
    syncDevice.on('pause', onPause);

	audioElement = document.getElementById("audio");
    audioElement.addEventListener('canplay', onAudioReady);

}

function onAudioReady() {
    if(demoMode) {
        audioElement.play();
    }
    render();
}

function onSyncReady(){
  //jsRocket is done getting all the info you already have in Rocket, or is done parsing the .rocket file

  //this either adds a track to Rocket, or gets it for you
  current_scene = syncDevice.getTrack('current_scene');
  scene1_meshx = syncDevice.getTrack('scene1_meshx');
  scene1_meshy = syncDevice.getTrack('scene1_meshy');
  scene1_meshz = syncDevice.getTrack('scene1_meshz');
  scene1_meshr = syncDevice.getTrack('scene1_meshr');
  scene1_mesha = syncDevice.getTrack('scene1_mesha');

  scene2_camerar = syncDevice.getTrack('scene2_camerar');
  scene2_effutime = syncDevice.getTrack('scene2_effutime');
  syncReady = true;
}

function onSyncUpdate(newRow){
  //row is only given if you navigate, or change a value on the row in Rocket
  //on interpolation change (hit [i]) no row value is sent, as the current there is the upper row of your block
  if(!isNaN(row)){
    row = newRow;
  }
  audioElement.currentTime = row/ROW_RATE;
  render();
}

function onPlay(){
  //you could also set tune.currentTime here
  console.log("[onPlay] time in seconds", row / ROW_RATE);
  audioElement.play();
  render();
}

function onPause(){
  //pause your tune
  console.log("[onPause] time in seconds", row / ROW_RATE);
  audioElement.pause();
}

var sceneTime = 0;
var sceneStartTime = 0;
var prevTime = 0;
var delta = 0;

function clamp(num, min, max) {
  return num <= min ? min : num >= max ? max : num;
}

function easeInOut(t) {
  return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1
}

function render() {
    if (syncReady === false) return;
    var currentRow = audioElement.currentTime * ROW_RATE;
            if(audioElement.paused === false) {
                //otherwise we may jump into a point in the audio where there's
                //no timeframe, resulting in Rocket setting row 2 and we report
                //row 1 back - thus Rocket spasming out
                // this informs Rocket where we are
                syncDevice.update(currentRow);
            }

    millis = (currentRow/ROW_RATE)-sceneStartTime;

    delta = millis-prevTime;
    sceneTime+=delta;

    sceneIndex = current_scene.getValue(currentRow);

    if (prevSceneIndex != sceneIndex) {
        prevSceneIndex = sceneIndex;
        sceneStartTime = millis;
    }

    if (sceneIndex == 0) {
        scenePass.camera = cameraPalaset;
        scenePass.scene = scenePalaset;
        tuniform.iTime.value = scene2_effutime.getValue(currentRow);
        cameraPalaset.rotation.y = scene2_camerar.getValue(currentRow);
        cameraPalaset.position.y = 0.0;
        sphereMesh.position.z = 0.2;
        composer.render(clock.getDelta());
//    	renderer.render( scenePalaset, cameraPalaset );
    } else if (sceneIndex == 1) {
        scenePass.camera = cameraTolppa;
        scenePass.scene = sceneTolppa;

        var animTime = clamp(sceneTime*0.1,0.0,1.0);
        sphereMesh2.position.x = scene1_meshx.getValue(currentRow);
        sphereMesh2.position.y = scene1_meshy.getValue(currentRow);
        sphereMesh2.position.z = scene1_meshz.getValue(currentRow);
        sphereMesh2.rotation.y = scene1_meshr.getValue(currentRow);
        tuniform.iTime.value = millis;
        tuniform.iAlpha.value = scene1_mesha.getValue(currentRow);
        materialTolppa.opacity = THREE.Math.lerp(0.0,0.1,easeInOut(animTime));

        cameraTolppa.lookAt(new THREE.Vector3(0.0,0.05,0.5));
        cameraTolppa.rotation.y = 0.0+Math.sin(millis*0.5)*0.1;
        cameraTolppa.position.y = Math.cos(millis*0.4)*.01;
        composer.render(clock.getDelta());
        //renderer.render( sceneTolppa, cameraTolppa );

    }

    prevTime = millis;
    if (audioElement.paused === false) window.requestAnimationFrame(render);


}
</script>
</head>

<body>
<script>
	window.addEventListener('load', function() {
		init();
		console.log("demo start");
	}, false);

</script>
<audio id="audio" style = "display:none" preload="auto">
	<source src="pzlu3.ogg" id="oggSource" type="audio/ogg" />
	<source src="pzlu3.mp3" id="mp3Source" type="audio/mpeg" />
</audio>
</body>
</html>
